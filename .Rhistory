try(write.csv(result$solute_equilibrium$species_conc, paste0("../temp_drop/", result_name, "_speciation.csv")), silent = TRUE)
} else if (result_type == "trans") {
}
# upload to github repo: git@github.com:RoKo-reuther/temp_drop.git
system("cd ../temp_drop && git add . && git commit -m 'update' && git push")
}
#| echo: true
#| code-fold: true
solve_tableau <- function(component_total, tableau, logK, N_grid, tableau_species) {
# load shared object
dyn.load("solve_tableau.so")
res <- .Fortran("solve_tableau",
component_total = as.double(component_total),
tableau         = matrix(as.double(tableau), ncol = ncol(tableau)),
logK            = as.double(logK),
N_components    = as.integer(ncol(tableau)),
N_species       = as.integer(nrow(tableau)),
N_grid          = as.integer(N_grid),
iter_pcfm       = rep(as.integer(0), N_grid),
iter_newton     = rep(as.integer(0), N_grid),
info_newton     = rep(as.integer(0), N_grid),
difference      = matrix(as.double(0), ncol = ncol(tableau), nrow = N_grid),
species_conc    = matrix(as.double(0), ncol = nrow(tableau), nrow = N_grid),
success         = rep(as.integer(0), N_grid)
)
colnames(res$species_conc) <- tableau_species
return(res)
}
#| echo: true
#| code-fold: true
speciation_ratios <- function(pH, tableau, tableau_species, logK) {
# determine number of total components TOT_X in tableau
N_components <- ncol(tableau)
# prepare vector with "component-concentrations"
# here we are only interested in ratios at a fixed pH ...
# so the only one that matters is the first one: TOT_H; the rest is set to 1
component_conc <- c(log10(10^-pH * 10^3), rep(1, N_components - 1))
# calculate species concentrations
species_conc <- as.list(10**(tableau %*% component_conc + logK))
# name entries
names(species_conc) <- tableau_species
# calculate ratios of interest
with(species_conc, {
ratios <- c(
fixed_H = 10^-pH * 10^3,
f_H2CO3 = H2CO3 / sum(H2CO3, HCO3, CO3),
f_HCO3  =  HCO3 / sum(H2CO3, HCO3, CO3),
f_CO3   =   CO3 / sum(H2CO3, HCO3, CO3),
f_H2S   =   H2S / sum(H2S, HS, S2),
f_HS    =    HS / sum(H2S, HS, S2),
f_S2    =    S2 / sum(H2S, HS, S2),
f_H3PO4 = H3PO4 / sum(H3PO4, H2PO4, HPO4, PO4),
f_H2PO4 = H2PO4 / sum(H3PO4, H2PO4, HPO4, PO4),
f_HPO4  = HPO4  / sum(H3PO4, H2PO4, HPO4, PO4),
f_PO4   = PO4   / sum(H3PO4, H2PO4, HPO4, PO4),
f_NH4   = NH4   / sum(NH4, NH3),
f_NH3   = NH3   / sum(NH4, NH3)
)
return(ratios)
})
}
#| echo: true
#| code-fold: true
plot_simple_comparision <- function(a, b, a_name, b_name, grid, xlab, ylab, log = "") {
plot(
grid$x.mid ~ a,
ylim = c(max(grid$x.int), min(grid$x.int)),
xlim = c(min(a, b), max(a, b)),
type = "l",
ylab = ylab,
xlab = xlab,
lwd = 2,
col = "gray45",
lty = 2,
log = log
)
points(
grid$x.mid ~ b,
type = "l",
lwd = 2,
col = "black"
)
legend(
"bottomright",
legend = c(a_name, b_name),
col = c("gray45", "black"),
lwd = 2,
lty = c(2, 1),
box.lwd = 0
)
}
plot_std_profiles <- function(std_gray, std_black, grid) {
std_black <- cbind(grid = grid$x.mid, std_black$y)
plot(std_gray, xyswap = TRUE, xlab = "mol/m3_phase", ylab = "depth (m)",
grid = grid$x.mid,
which = model_species,
col = "gray45",
lty = 2,
lwd = 2,
cex = 1.5,
mfrow = c(1,1),
obs = std_black,
obspar = c(type = "l", lwd = 2, col = "black")
)
}
plot_std_rates <- function(std, reactions, title = "") {
# rcols <- viridis::viridis(length(std$rates))
#
# matplot(y = grid$x.mid,
#         x = as.data.frame(std$rates),
#         type = "l", lwd=2, lty=1,
#         ylim = c(length,0),
#         col = rcols,
#         ylab="depth (m)",
#         xlab="reaction rate (mol/(m3_bulk yr))")
#
# legend(
#   x = "bottomright",
#   legend = names(std$rates),
#   lty = 1,
#   col = rcols <- viridis::viridis(length(std$rates)),
#   lwd = 2
# )
data <- as.data.frame(std$rates)
data$depth <- grid$x.mid
fig <- plot_ly(data, type = 'scatter', mode = 'lines', line = list(width = 3))
for (rate in reactions) {
fig <- fig %>% add_trace(y = ~depth, x = std$rates[[rate]], name = rate)
}
fig <- fig %>% layout(
title = title,
xaxis = list(title = "reaction rate (mol/(m3_bulk yr))"),
yaxis = list(title = "depth (m)", range = c(length,0)),
font = list(size = 16)
)
fig
#| echo: true
porFun.L  <- function(x, por.SWI, por.deep, porcoef) {
return( por.deep + (por.SWI-por.deep) * exp(-x*porcoef) )
}
porFun.S  <- function(x, por.SWI, por.deep, porcoef) {
return( 1 - porFun.L(x, por.SWI, por.deep, porcoef) )
}
por.swi  <- 0.818
por.deep <- 0.818
grid.por <- setup.prop.1D(func = porFun.L, grid = grid, por.SWI = por.swi,
por.deep=por.deep, porcoef=100)
#| echo: true
length   <- 0.2 # (m)
N_grid   <- 200 # (-)
grid     <- setup.grid.1D(L = length, N = N_grid, dx.1 = 0.0005)
#| echo: true
porFun.L  <- function(x, por.SWI, por.deep, porcoef) {
return( por.deep + (por.SWI-por.deep) * exp(-x*porcoef) )
}
porFun.S  <- function(x, por.SWI, por.deep, porcoef) {
return( 1 - porFun.L(x, por.SWI, por.deep, porcoef) )
}
por.swi  <- 0.818
por.deep <- 0.818
grid.por <- setup.prop.1D(func = porFun.L, grid = grid, por.SWI = por.swi,
por.deep=por.deep, porcoef=100)
grid.svf  <- setup.prop.1D(func = porFun.S, grid = grid, por.SWI = por.swi,
por.deep=por.deep, porcoef=100)
conversion_factors <- list(
s2p = ((grid.svf$mid) / grid.por$mid), # conversion of x/m3_svf to x/m3_pw
p2s = (grid.por$mid / (grid.svf$mid))  # conversion of x/m3_pw  to x/m3_svf
)
#| echo: true
# sedimentation velocity
v <- 0.002  # (m/yr)
# returns pore water advective velocities (u) and solid phase advective velocities (v)
advective_velocities <- setup.compaction.1D(
v.0 = v,
por.0 = por.swi,
por.inf = por.deep,
por.grid = grid.por
)
#| echo: true
grid.k_iri <- setup.prop.1D(
func = p.exp,
grid = grid,
y.0 = 200, # yr-1
y.inf = 0, # yr-1
x.att = 0.035
)
#| echo: true
salinity    <- 35 # (psu)
temperature <- 5  # (dgC)
pressure    <- 1.013253 # (bar)
grid.Db <- setup.prop.1D(
func = function(x){ifelse(x <= 0.2, 0.002, 0)}, # 0.002
grid = grid
)
tortuosity_squared <- 1 - log(grid.por$int^2)
s2yr <- 3600 * 24 * 365.25
diffcoeff_species <- c("HCO3", "HCO3", "CH4", "H2PO4", "NO3", "NH4", "SO4",
"O2", "Mn", "Fe", "H2S", "N2", "Ca")
diffcoeffs <- diffcoeff(
species = diffcoeff_species,
S = salinity,
t = temperature,
P = pressure
)
diffusion_coefficients <- list(
# solute: molar diffusion coefficient / tortuosity**2 + bioturbation coefficient
# solid: bioturbation coefficient
ALK   = diffcoeffs[[1]]  * s2yr / tortuosity_squared,
DIC   = diffcoeffs[[2]]  * s2yr / tortuosity_squared,
CH4   = diffcoeffs[[3]]  * s2yr / tortuosity_squared,
H2PO4 = diffcoeffs[[4]]  * s2yr / tortuosity_squared,
NO3   = diffcoeffs[[5]]  * s2yr / tortuosity_squared,
NH4   = diffcoeffs[[6]]  * s2yr / tortuosity_squared,
SO4   = diffcoeffs[[7]]  * s2yr / tortuosity_squared,
O2    = diffcoeffs[[8]]  * s2yr / tortuosity_squared,
Mn2   = diffcoeffs[[9]]  * s2yr / tortuosity_squared,
Fe2   = diffcoeffs[[10]] * s2yr / tortuosity_squared,
H2S   = diffcoeffs[[11]] * s2yr / tortuosity_squared,
N2    = diffcoeffs[[12]] * s2yr / tortuosity_squared,
Ca2   = diffcoeffs[[13]] * s2yr / tortuosity_squared,
solid = grid.Db$int
)
#| echo: true
boundary_conditions <- c(
# Alkalinity in eq/m3?
ALK_up   = 2.5, #!
# Solutes: concentrations in mol m-3
DIC_up   = 2.56,
CH4_up   = 0,
H2PO4_up = 0.00235,
NO3_up   =  0.0015, #!
NH4_up   = 0.022, #!
SO4_up   = 28, #!
O2_up    = 0.213, #!
N2_up    = 0,
Mn2_up   = 0.002, #!
Fe2_up   = 0, #!
H2S_up   = 0, #!
Ca2_up   = 1.17,
# Solids: flux in mol m-2 yr-1
OM_up      = 0.017 * 365, #0.013
OM_beta_up = 0,
MnO2_up    = 0.4, #!
FeOH3_up   = 0.75, #!
FeOH3_P_up = 0,
FeCO3_up   = 0,
S0_up      = 0, #!
FeS_up     = 0,
Viv_up     = 0,
CaCO3_up   = 0,
Apatite_up = 0,
MnCO3_up   = 0
)
#| echo: true
dry_density_sediment <- 2700 # kg/mÂ³
reaction_parameter <- c(
# OM degradation
## reaction constants
k_alpha = 3e-3 * 365, # yr-1; 0.005 * 365
k_beta  = 6e-5 * 365, # yr-1
## composition of OM
OM_a    = 1,
OM_b    = 1 / 8.8,
OM_c    = 1 / 106,
## limitation / inhibition constants (mol m-3)
K_O2    = 0.02,
K_NO3   = 0.002,
K_MnO2  = 0.016 * dry_density_sediment,#0.004 * dry_density_sediment,
K_FeOH3 = 0.1 * dry_density_sediment,#0.065 * dry_density_sediment,
K_SO4   = 1.6,
K_H3PO4 = 10^-5,
## ratio of Fe to P in Fe(OH)_3(H3PO4)_lambda
lambda  = 0.6,
# Siderite Precipitation / Dissolution
k_precip_siderite = 1215,   # mol m-3_sf yr-1
k_diss_siderite   = 2.5e-1, # yr-1
Ksp_siderite      = 10^(-8.4) * 1000^2, # mol2 m-6
# Siderite Precipitation / Dissolution
#k_precip_siderite = 1.8e2,   # mol m-3_sf yr-1
#k_diss_siderite   = 2.5e-1, # yr-1
#Ksp_siderite      = 10^(-10.4) * 1000^2, # mol2 m-6
# FeOH3 / FeOH3~H3PO4-Reduction coupled to Sulphide Oxidation
k_Fe_red_S_ox = 8, # m3 mol-1 yr-1
# FeOH3 / FeOH3~H3PO4-Formation
k_FeOH3_formation = 1.4e5, # m3 mol-1 yr-1
# H2S Oxidation
k_H2S_oxidation = 1.6e2, # m3_pw mol-1 yr-1
# SO4 Reduction Coupled to AOM
k_SO4_reduction = 10, # m3_pw mol-1 yr-1
# FeS Precipitation / Dissolution
k_precip_FeS = 40.5, # mol m-3_sf yr-1
k_diss_FeS   = 1 * 1e-3, # yr-1
Ksp_FeS      = 10^(-2.2) * 1000, # mol m-3
#k_precip_FeS = 40.5, # mol m-3_sf yr-1
#k_diss_FeS   = 1 * 1e-3, # yr-1
#Ksp_FeS      = 10^(-2.2) * 1000, # mol m-3
# Vivianite Precipitation / Dissolution
k_precip_Viv = 0 * 1.1e-2, # mol m-3_sf yr-1
k_diss_Viv   = 0 * 5.3e-3, # yr-1
Ksp_Viv      = 10^(-36) * 1000^5, # mol3 m-9
# CaCO3 Precipitation / Dissolution
k_precip_CaCO3 = 0 * 1.1e-1,  # mol m-3_sf yr-1
k_diss_CaCO3   = 0 * 1.25e-1, # mol m-3_sf yr-1
Ksp_CaCO3      = 10^(-8.48) * 1000^2, # mol2 m-6
# Apatite Precipitation / Dissolution
k_precip_Apatite = 0 * 1.4e-6, # mol m-3 yr-1
k_diss_Apatite   = 0 * 3.7e-2, # yr-1
Ksp_Apatite      = 6e-20,  # mol3 m-9; 6e-20
# Oxidation of Fe2 by MnO2
k_I11 = 3e3,
# Ammonium Oxidation
k_I12 = 5e3,
# Sulphide Oxidation by MnO2
k_I14 = 20,
# FeS Oxidation by O2
k_I16 = 3.2e2,
# CH4 Oxidation by O2
k_I17 = 1e7,
# MnCO3 Precipitation / Dissolution
k_precip_MnCO3 = 270,
k_diss_MnCO3 = 0.8,
Ksp_MnCO3 = 10^(-8.5) * 1000^2
)
#| echo: true
#ratios_pH7 <- speciation_ratios(pH = 7, tableau, tableau_species, logK)
pH_profile <- read.csv("./WangVanCapProfiles/WVC_pH_profile.csv")
colnames(pH_profile) <- c("pH", "depth")
pH_profile$depth <- pH_profile$depth * 0.01
pH_in_layers <- approx(y = pH_profile$pH, x = pH_profile$depth, xout = grid$x.mid)
srm <- matrix(ncol = N_grid, nrow = 13)
for (i in seq(1, N_grid)) {
srm[,i] <- speciation_ratios(pH = pH_in_layers$y[i], tableau, tableau_species, logK)
}
ratios <- list(
fixed_H = as.vector(srm[1,]),
f_H2CO3 = as.vector(srm[2,]),
f_HCO2  = as.vector(srm[3,]),
f_CO3   = as.vector(srm[4,]),
f_H2S   = as.vector(srm[5,]),
f_HS    = as.vector(srm[6,]),
f_S2    = as.vector(srm[7,]),
f_H3PO4 = as.vector(srm[8,]),
f_H2PO4 = as.vector(srm[9,]),
f_HPO4  = as.vector(srm[10,]),
f_PO4   = as.vector(srm[11,]),
f_NH4   = as.vector(srm[12,]),
f_NH3   = as.vector(srm[13,])
)
parameter <- c(
N_grid = N_grid,
conversion_factors,
boundary_conditions,
reaction_parameter,
ratios,
logK = logK,
tableau = tableau,
tableau_species = tableau_species
)
N_species <- length(model_species)
srm
length(srm)
srm[1:14,1:14]
srm[1:13,1:14]
N_grid
seq(1, N_grid)
ncol(srm)
pH_in_layers[200]
pH_in_layers$y[200]
pH_in_layers
?approx
pH_in_layers <- approx(y = pH_profile$pH, x = pH_profile$depth, xout = grid$x.mid, rule = 2)
srm <- matrix(ncol = N_grid, nrow = 13)
for (i in seq(1, N_grid)) {
srm[,i] <- speciation_ratios(pH = pH_in_layers$y[i], tableau, tableau_species, logK)
}
pH_in_layers
srm
grid
grid.Db <- setup.prop.1D(
func = p.sig,
y.0 = 0.002,
y.inf = 0.0002,
x.L = 0.1,
x.att = 1,
grid = grid
)
plot(grid.Db, grid = grid)
plot(grid.Db, grid = grid, xyswap = TRUE)
grid.Db <- setup.prop.1D(
func = p.sig,
y.0 = 0.002,
y.inf = 0.0002,
x.L = 0.1,
x.att = 100,
grid = grid
)
plot(grid.Db, grid = grid, xyswap = TRUE)
grid.Db <- setup.prop.1D(
func = p.sig,
y.0 = 0.002,
y.inf = 0.0002,
x.L = 0.1,
x.att = 0.001,
grid = grid
)
plot(grid.Db, grid = grid, xyswap = TRUE)
grid.Db <- setup.prop.1D(
func = p.sig,
y.0 = 0.002,
y.inf = 0.0002,
x.L = 0.1,
x.att = 0.01,
grid = grid
)
plot(grid.Db, grid = grid, xyswap = TRUE)
grid.Db <- setup.prop.1D(
func = p.sig,
y.0 = 0.002,
y.inf = 0.0002,
x.L = 0.2,
x.att = 0.05,
grid = grid
)
plot(grid.Db, grid = grid, xyswap = TRUE)
grid <- setup.grid.1D(L = 0.6, N = 200)
grid.Db <- setup.prop.1D(
func = p.sig,
y.0 = 0.002,
y.inf = 0.0002,
x.L = 0.2,
x.att = 0.05,
grid = grid
)
plot(grid.Db, grid = grid, xyswap = TRUE)
plot(grid.k_iri, grid = grid)
plot(grid.k_iri, grid = grid, xwswap = TRUE)
plot(grid.k_iri, grid = grid, xyswap = TRUE)
grid.k_iri <- setup.prop.1D(
func = p.exp,
grid = grid,
y.0 = 200, # yr-1
y.inf = 0, # yr-1
x.att = 0.035
)
plot(grid.k_iri, grid = grid, xyswap = TRUE)
grid.k_iri
grid.correct_k_iri <- setup.prop.1D(
func = p.sig,
y.0 = 1,
y.inf = 0,
x.L = 0.1,
x.att = 1,
grid = grid
)
plot(grid.correct_k_iri, grid = grid, xyswap = TRUE)
grid.correct_k_iri <- setup.prop.1D(
func = p.sig,
y.0 = 1,
y.inf = 0,
x.L = 0.1,
x.att = 0.1,
grid = grid
)
plot(grid.correct_k_iri, grid = grid, xyswap = TRUE)
grid.correct_k_iri <- setup.prop.1D(
func = p.sig,
y.0 = 1,
y.inf = 0,
x.L = 0.1,
x.att = 0.01,
grid = grid
)
plot(grid.correct_k_iri, grid = grid, xyswap = TRUE)
grid.correct_k_iri <- setup.prop.1D(
func = p.sig,
y.0 = 1,
y.inf = 0,
x.L = 0.15,
x.att = 0.01,
grid = grid
)
plot(grid.correct_k_iri, grid = grid, xyswap = TRUE)
grid.Db <- setup.prop.1D(
+     func = p.sig,
grid.Db <- setup.prop.1D(
func = p.sig,
y.0 = 0.002,
y.inf = 0.0002,
x.L = 0.2,
x.att = 0.05,
grid = grid
)
plot(grid.Db, grid = grid, xyswap = TRUE)
grid.correct_k_iri <- setup.prop.1D(
func = p.sig,
y.0 = 1,
y.inf = 0,
x.L = 0.15,
x.att = 0.01,
grid = grid
)
grid.k_iri <- setup.prop.1D(
func = p.exp,
grid = grid,
y.0 = 200, # yr-1
y.inf = 0, # yr-1
x.att = 0.035
)
grid.k_iri$mid <- grid.k_iri$mid * grid.correct_k_iri$mid
grid.k_iri$int <- grid.k_iri$int * grid.correct_k_iri$int
plot(grid.k_iri, grid = grid, xyswap = TRUE)
grid.k_iri
