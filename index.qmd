---
title: "Fe Treatment Model"

#server: shiny

execute:
  echo: false
  eval: true

bibliography: FeTreatment.bib
---

```{r load libraries}
#| message: false

require(readODS)
require(marelac)
require(ReacTran)
require(microbenchmark)
require(plotly)
```

## Concept

### Reactions

Reactions affect solute and solid model species differently.

The solid model species are the same occurring in the chemical reaction equations.
Therefore they are affected directly according to the reaction stoichiometry.

Solute model species are either component-totals (e.g. DIC, TOT_P, ...) to be speciated later or species on their own (e.g. O2, CH4).
The effect of reactions on solute species is first formulated for the species occurring in the chemical reaction equations according to the reaction stoichiometry.
In a second step this changes are translated to changes of the component-totals / model species using a translation table.

### Transport

For solutes the (probably) dominant species of a component-total governs the diffusion coefficient (cf code-block "Diffusion Coefficients").
The transport of solids is not affected by species properties.


## Reactions Describing OM Decomposition

### OM Composition

$\ce{(CH2O)_a (NH3)_b (H3PO4)_c}$

- $a = 1$
- $b = 16/106$
- $c = 1/106$


### Rate Constants

- $k_{\alpha} = 0.05 - 1.62 \: yr^{-1}$    [@moodley2005; @tromp1995global]
- $k_{\beta} = 0.025 - 0.0086 \: yr^{-1}$  [@tromp1995global]


### Limitation (L) and Inihibition (I) Terms

#### O2

$L_{\ce{O2}} = \frac{[\ce{O2}]}{K_{\ce{O2}} + [\ce{O2}]}$

$I_{\ce{O2}} = \frac{K_{\ce{O2}}}{K_{\ce{O2}} + [\ce{O2}]}$

with $K_{O2} = 0.001 - 0.03 \: mol \: m^{-3}_{pw}$ [@wang1996multicomponent]

#### NO3-

$L_{\ce{NO3^-}} = \frac{[\ce{NO3^-}]}{K_{\ce{NO3-}} + [\ce{NO3^-}]}$

$I_{\ce{NO3^-}} = \frac{K_{\ce{NO3^-}}}{K_{\ce{NO3^-}} + [\ce{NO3^-}]}$

with $K_{NO3-} = 0.004 - 0.08  \: mol \: m^{-3}_{pw}$ [@wang1996multicomponent]

#### MnO2

$L_{\ce{MnO2^{\alpha}}} = \frac{[\ce{MnO2^{\alpha}}]}{K_{\ce{MnO2}} + [\ce{MnO2^{\alpha}}]}$
 
$I_{\ce{MnO2^{\alpha}}} = \frac{K_{\ce{MnO2}}}{K_{\ce{MnO2}} + [\ce{MnO2^{\alpha}}]}$

with $K_{\ce{MnO2^{\alpha}}} = \{0.004 - 0.032\} \: mol \: {kg}^{-1} \cdot \rho_{dry}$  [@wang1996multicomponent]

#### Fe(OH)3

$L_{\ce{Fe(OH)3_{; tot}^\alpha}} = \frac{[\ce{Fe(OH)3_{; tot}^\alpha}]}{K_{\ce{Fe(OH)3}} + [\ce{Fe(OH)3_{; tot}^\alpha}]}$

$I_{\ce{Fe(OH)3^\alpha}} = \frac{K_{\ce{Fe(OH)3}}}{K_{\ce{Fe(OH)3}} + [\ce{Fe(OH)3_{; tot}^\alpha}]}$

with $K_{\ce{FeOH3}} = \{0.065 - 0.1\} \: mol \: {kg}^{-1} \cdot \rho_{dry}$ [@wang1996multicomponent]

#### SO42-

$L_{\ce{SO4^{2-}}} = \frac{[\ce{SO4^{2-}}]}{K_{\ce{SO4^{2-}}} + [\ce{SO4^{2-}}]}$

$I_{\ce{SO4^{2-}}} = \frac{K_{\ce{SO4^{2-}}}}{K_{\ce{SO4^{2-}}} + [\ce{SO4^{2-}}]}$

with $K_{SO42-} = 0.0016  \: mol \: {m^{-3}_{pw}}$ [@wang1996multicomponent]

#### H3PO4

$L_{\ce{H3PO4}} = \frac{[\ce{H3PO4}]}{K_{\ce{H3PO4}} + [\ce{H3PO4}]}$

with $K_{\ce{H3PO4}} = 10^{-5} \: mol \: m^{-3}_{pw}$ (Reinier)

> formulated for lump sum

### FeOH3 Fractions

$\ce{Fe(OH)3_{; tot}^\alpha} = \ce{Fe(OH)3^{\alpha}} + \ce{Fe(OH)3^\alpha(H3PO4)_{\lambda}}$ with $\lambda = 0.6$

$\chi = \frac{[\ce{Fe(OH)3^{\alpha}}]}{[\ce{Fe(OH)3_{; tot}^\alpha}]}$


### Reactions

#### OM + O2 (R1)

$\ce{OM^{\alpha, \beta} + O2 -> CO2 + b NH3 + c H3PO4 + H2O}$

$R = k_{\alpha, \beta} \: OM^{\alpha, \beta} \: L_{\ce{O2}}$


#### OM + HNO3 (R2)

$\ce{OM^{\alpha, \beta} + 4/5 HNO3 -> CO2 + b NH3 + c H3PO4 + 2/5 N2 + 7/5 H2O}$

$R = k_{\alpha, \beta} \: OM^{\alpha, \beta} \: L_{\ce{NO3-}} \: I_{\ce{O2}}$


#### OM + MnO2 (R3)

$\ce{OM^{\alpha, \beta} + 2 MnO2 + H2O -> CO2 + b NH3 + c H3PO4 + 2 Mn(OH)2}$

$R = k_{\alpha, \beta} \: OM^{\alpha, \beta} \: L_{\ce{MnO2}^\alpha} \: I_{\ce{NO3^-}} \: I_{\ce{O2}}$


#### OM + FeOH3 / FeOH3~H3PO4 (R4)

$\ce{OM^{\alpha, \beta} + 4 (\chi Fe(OH)3^{\alpha} + (1 - \chi) Fe(OH)3^\alpha(H3PO4)_{\lambda} ) -> CO2 + b NH3 + (c + (1- \chi) 4 \lambda) H3PO4 + 4 Fe(OH)2 + 3 H2O}$

$R = k_{\alpha, \beta} \: OM^{\alpha, \beta} \: L_{\ce{Fe(OH)3_{; tot}^\alpha}} \: I_{\ce{MnO2^{\alpha}}} \: I_{\ce{NO3^-}} \: I_{\ce{O2}}$


#### OM + H2SO4 (R5)

$\ce{OM^{\alpha, \beta} + 1/2 H2SO4 -> CO2 + b NH3 + c H3PO4 + 1/2 H2S + H2O}$

$R = k_{\alpha, \beta} \: OM^{\alpha, \beta} \: L_{\ce{SO4^{2-}}} \: I_{\ce{Fe(OH)3^\alpha}} \: I_{\ce{MnO2^{\alpha}}} \: I_{\ce{NO3^-}} \: I_{\ce{O2}}$


#### Methanogenesis (R6)

$\ce{OM^{\alpha, \beta} -> 1/2 CO2 + b NH3 + c H3PO4 + 1/2 CH4}$

$R = k_{\alpha, \beta} \: OM^{\alpha, \beta} \: I_{\ce{SO4^{2-}}} \: I_{\ce{Fe(OH)3^\alpha}} \: I_{\ce{MnO2^{\alpha}}} \: I_{\ce{NO3^-}} \: I_{\ce{O2}}$


## Precipitation Reactions

### Siderite

In general:

$\ce{FeCO3 <-> Fe^{2+} + CO3^{2-}}$

In our model:

$\ce{FeCO3 + 2 H2O <-> Fe(OH)2 + H2CO3}$

Precipitation and Dissolution are split in two reactions from which only one is active at a time, depending on the saturation state $\Omega$.

$\Omega = \frac{\ce{[Fe^{2+}]} \cdot \ce{[CO3^{2-}]}}{K_{sp; siderite}} \quad$
with $\quad K_{sp; siderite} = 10^{-10.4} \; mol^2 \; m^{-6}$

If $\: \Omega > 1$:

- $R_{precipitation} = k_{precip} \cdot (\Omega - 1) \quad$
with $\quad k_{precip} \approx 1 \times 10^{-3} \; mol \; {m_{pw}}^{-3} \; yr^{-1}$
- $R_{dissolution} = 0$

If $\: \Omega < 1$:

- $R_{precipitation} = 0$
- $R_{dissolution} = - k_{diss} \cdot \ce{[FeCO3]} \cdot (\Omega - 1) \quad$
with $\quad k_{diss} \approx 1 \times 10^{-2} \; yr^{-1}$


## Equilibrium Reactions described via Tableau

```{r read tableau}
excel <- read_fods("tableau.fods", sheet = "morel_tableau")

tableau_print <- as.data.frame(excel)

excel[is.na(excel)] <- 0

column_H2O  <- 2
column_logK <- 10
column_species_names <- 1
row_H2O     <- 1

tableau <- as.matrix(excel[-row_H2O,-c(column_H2O, column_logK, column_species_names)])

logK <- as.vector(unlist(excel[-row_H2O, column_logK]))

tableau_species <- unlist(excel[,column_species_names])[-1]
names(tableau_species) <- NULL

model_species <- c("ALK", "DIC", "TOT_P", "TOT_N5", "TOT_N3", "TOT_S6", "TOT_S2", "CH4", "O2", "N2", "Mn2", "Fe2", "MnO2", "OM", "FeOH3", "FeOH3_P", "FeCO3")

#excel <- read_xlsx("tableau.xlsx", sheet = "translation_table")
#excel[is.na(excel)] <- 0

rm(column_H2O, column_logK, column_species_names, row_H2O, excel)
```

The Tableau is used to calculate equilibrium speciation of solute species after model run.
Fast equilibrium reactions are neglected during model runtime (so far).

```{r print tableau}
options(knitr.kable.NA = '')
knitr::kable(tableau_print)
```


## Functions

### Solve Tableau

```{r def solve_tableau}
#| echo: true
#| code-fold: true

solve_tableau <- function(component_total, tableau, logK, N_grid) {
  
  # load shared object
  dyn.load("solve_tableau.so")

  return(.Fortran("solve_tableau",
                  component_total = as.double(component_total),
                  tableau         = matrix(as.double(tableau), ncol = ncol(tableau)),
                  logK            = as.double(logK),
                  N_components    = as.integer(ncol(tableau)),
                  N_species       = as.integer(nrow(tableau)),
                  N_grid          = as.integer(N_grid),
                  iter_pcfm       = rep(as.integer(0), N_grid),
                  iter_newton     = rep(as.integer(0), N_grid),
                  info_newton     = rep(as.integer(0), N_grid),
                  difference      = matrix(as.double(0), ncol = ncol(tableau), nrow = N_grid),
                  species_conc    = matrix(as.double(0), ncol = nrow(tableau), nrow = N_grid),
                  success         = rep(as.integer(0), N_grid)
                  )
  )
  
}
```

### Plot steady.1D results

```{r def plot functions 1}
#| echo: true
#| code-fold: true

plot_std_profiles <- function(std) {
  
  plot(std, xyswap = TRUE, xlab = "mol/m3_phase", ylab = "depth (m)",
       grid = grid$x.mid,
       which = model_species,
       lwd = 2,
       cex = 1.5,
       mfrow = c(1,1)
  )
}

plot_std_rates <- function(std) {
  
  # rcols <- viridis::viridis(length(std$rates))
  # 
  # matplot(y = grid$x.mid,
  #         x = as.data.frame(std$rates),
  #         type = "l", lwd=2, lty=1,
  #         ylim = c(length,0), 
  #         col = rcols,
  #         ylab="depth (m)", 
  #         xlab="reaction rate (mol/(m3_bulk yr))")
  # 
  # legend(
  #   x = "bottomright",
  #   legend = names(std$rates),
  #   lty = 1,
  #   col = rcols <- viridis::viridis(length(std$rates)),
  #   lwd = 2
  # )
  
  data <- as.data.frame(std$rates)
  data$depth <- grid$x.mid
  
  fig <- plot_ly(data, type = 'scatter', mode = 'lines', line = list(width = 3))
  for (rate in names(std$rates)) {
    fig <- fig %>% add_trace(y = ~depth, x = std$rates[[rate]], name = rate)
  }
  fig <- fig %>% layout(
    xaxis = list(title = "reaction rate (mol/(m3_bulk yr))"),
    yaxis = list(title = "depth (m)", range = c(length,0))
  )
    
  fig
}

plot_omega <- function(std) {
  plot(
    x = std$omega_siderite,
    y = grid$x.mid,
    ylim = c(max(grid$x.int), min(grid$x.int)),
    type = "l",
    lwd = 2,
    xlab = "omega siderite",
    ylab = "depth (m)",
    log = "x"
  )
}
```

### Plot Runge-Kutta results

```{r def plot functions 2}
#| echo: true
#| code-fold: true

plot_std_conc_evolution <- function(std_matrix_list, selection, N_lines, grid) {
  
  data <- std_matrix_list[[selection]]
  
  # number of available timesteps
  available_timesteps <- ncol(data)
  
  # selection of N_lines timesteps
  selected_timesteps <- floor(seq.int(1, available_timesteps, length.out = N_lines))
  
  # reduce data
  data <- data[,selected_timesteps]
  
  # plot
  matplot(y = grid$x.mid,
          x = data,
          type = "l",
          ylim = c(max(grid$x.mid), min(grid$x.mid)),
          xlab = "concentration (mol/m^3_phase)",
          ylab = "depth (m)",
          main = selection)
}

plot_std_rate_evolution <- function(std, selection, N_lines) {
  
  data <- std$rates_split[[selection]]
  
  # number of available depths
  available_depths <- nrow(data)
  
  # selection of N_lines depths
  selected_depths <- floor(seq.int(1, available_depths, length.out = N_lines))
  
  # reduce data
  data <- data[selected_depths,]
  
  # plot
  matplot(x = std$times,
          y = t(data),
          type = "l",
          ylab = "rate (mol/(m^3_phase * yr))",
          xlab = "time (a)",
          main = selection)
}
```


## Model Setup

### Grid
```{r grid setup}
#| echo: true

length   <- 0.1 # (m)
N_grid   <- 400 # (-)

grid     <- setup.grid.1D(L = length, N = N_grid, dx.1=0.0005)
```

### Porosity / Solid Volume Fraction
```{r porosity}
#| echo: true

porFun.L  <- function(x, por.SWI, por.deep, porcoef) {
  return( por.deep + (por.SWI-por.deep) * exp(-x*porcoef) ) 
}

porFun.S  <- function(x, por.SWI, por.deep, porcoef) {
  return( 1 - porFun.L(x, por.SWI, por.deep, porcoef) ) 
}

por.swi  <- 0.8
por.deep <- 0.8

grid.por <- setup.prop.1D(func = porFun.L, grid = grid, por.SWI = por.swi,
                           por.deep=por.deep, porcoef=100)

grid.svf  <- setup.prop.1D(func = porFun.S, grid = grid, por.SWI = por.swi,
                           por.deep=por.deep, porcoef=100)

conversion_factors <- list(
  s2p = ((grid.svf$mid) / grid.por$mid), # conversion of x/m3_svf to x/m3_pw
  p2s = (grid.por$mid / (grid.svf$mid))  # conversion of x/m3_pw  to x/m3_svf
)
```

### Advective Velocities
```{r advection}
#| echo: true

# sedimentation velocity
v <- 5e-6*365  # (m/yr)

# returns pore water advective velocities (u) and solid phase advective velocities (v)
advective_velocities <- setup.compaction.1D(
    v.0 = v,
    por.0 = por.swi,
    por.inf = por.deep,
    por.grid = grid.por
)
```

### Diffusion Coefficients
```{r diffusion}
#| echo: true

salinity    <- 35 # (psu)
temperature <- 20 # (dgC)
pressure    <- 1.013253 # (bar)
Db          <- 5e-4 # mixing rate of the sediment; Bioturbation coefficient (m2/y)
Db_mid      <- 0.5  # middle of Db decreasing zone (m)
Db_width    <- 0.01 # width of Db decreasing zone (m)

grid.Db <- setup.prop.1D(
    func = p.sig,
    y.0 = Db,
    y.inf = 0,
    x.L = Db_mid,
    x.att = Db_width,
    grid = grid
)

tortuosity_squared <- 1-log(grid.por$int^2)

s2yr <- 3600*24*365.25

diffcoeff_species <- c("HCO3", "HCO3", "CH4", "H2PO4", "NO3", "NH4", "SO4",
                       "O2", "Mn", "Fe", "H2S", "N2")

diffcoeffs <- diffcoeff(
  species = diffcoeff_species,
  S = salinity,
  t = temperature,
  P = pressure
)

diffusion_coefficients <- list(
  
  # solute: molar diffusion coefficient / tortuosity**2 + bioturbation coefficient
  # solid: bioturbation coefficient
  
  ALK   = diffcoeffs[[1]]  * s2yr / tortuosity_squared + grid.Db$int,
  DIC   = diffcoeffs[[2]]  * s2yr / tortuosity_squared + grid.Db$int,
  CH4   = diffcoeffs[[3]]  * s2yr / tortuosity_squared + grid.Db$int,
  H2PO4 = diffcoeffs[[4]]  * s2yr / tortuosity_squared + grid.Db$int,
  NO3   = diffcoeffs[[5]]  * s2yr / tortuosity_squared + grid.Db$int,
  NH4   = diffcoeffs[[6]]  * s2yr / tortuosity_squared + grid.Db$int,
  SO4   = diffcoeffs[[7]]  * s2yr / tortuosity_squared + grid.Db$int,
  O2    = diffcoeffs[[8]]  * s2yr / tortuosity_squared + grid.Db$int,
  Mn2   = diffcoeffs[[9]]  * s2yr / tortuosity_squared + grid.Db$int,
  Fe2   = diffcoeffs[[10]] * s2yr / tortuosity_squared + grid.Db$int,
  H2S   = diffcoeffs[[11]] * s2yr / tortuosity_squared + grid.Db$int,
  N2    = diffcoeffs[[12]] * s2yr / tortuosity_squared + grid.Db$int,
  solid = grid.Db$int
    
)
```

```{r plot por, Db, ...}
#| layout-ncol: 4
#| fig.height: 3.5
#| fig.width: 3.5

plot(x=grid.por$mid, y=grid$x.mid, type="l",
     ylim=c(length,0), ylab="depth (m)", xlab="porosity (m3_liq/m3_bulk)")
plot(x=diffusion_coefficients$solid, y=grid$x.int, type="l",
     ylim=c(length,0), ylab="depth (m)", xlab="D_solid (m2/yr)")
plot(x=diffusion_coefficients$DIC, y=grid$x.int, type="l",
     ylim=c(length,0), ylab="depth (m)", xlab="D_DIC (m2/yr)")
plot(x=diffusion_coefficients$O2, y=grid$x.int, type="l",
     ylim=c(length,0), ylab="depth (m)", xlab="D_O2 (m2/yr)")
```

### Boundary Conditions
```{r boundary conditions}
#| echo: true

boundary_conditions <- c(
  # Alkalinity in eq/m3?
  ALK_up   = 2,
  # Solutes: concentrations in mol m-3
  DIC_up   = 2,
  CH4_up   = 0,
  H2PO4_up = 0,
  NO3_up   = 0.2,
  NH4_up   = 0.001,
  SO4_up   = 28,
  O2_up    = 0.3,
  N2_up    = 0, # <<<
  Mn2_up   = 0,
  Fe2_up   = 0,
  H2S_up   = 0,
  # Solids: flux in mol m-2 yr-1
  OM_up      = 0.25 * 365,
  MnO2_up    = 10,
  FeOH3_up   = 10,
  FeOH3_P_up = 10,
  FeCO3_up   = 0
)
```

### Reaction Parameters
```{r reaction parameters}
#| echo: true

dry_density_sediment <- 2700 # kg/m³

reaction_parameter <- c(
  # OM degradation
  ## reaction constants
  k_alpha = 0.005 * 365, # yr-1
  k_beta  = 0,#0.025,    # yr-1
  ## composition of OM
  OM_a    = 1,
  OM_b    = 16 / 106,
  OM_c    = 1 / 106,
  ## limitation / inhibition constants (mol m-3)
  K_O2    = 0.001,
  K_NO3   = 0.001,
  K_MnO2  = 0.001 * dry_density_sediment,#0.004 * dry_density_sediment,
  K_FeOH3 = 0.001 * dry_density_sediment,#0.065 * dry_density_sediment,
  K_SO4   = 0.1,
  K_H3PO4 = 10^-5,
  ## ratio of Fe to P in Fe(OH)_3(H3PO4)_lambda
  lambda  = 0.6,
  # Siderite Precipitation / Dissolution
  k_precip_siderite = 1.8e2, # mol m-3_sf yr-1
  k_diss_siderite = 2.5e-1,  # yr-1
  Ksp_siderite = 10**(-10.4) * 1000**2
)
```

### Collect Inputs
```{r collect inputs}
#| echo: true

parameter <- c(
  N_grid = N_grid,
  conversion_factors,
  boundary_conditions,
  reaction_parameter,
  logK = logK,
  tableau = tableau
)

N_species <- length(model_species)
```

### Model Function
```{r model function}
#| echo: true
#| code-fold: show

model <- function (t, state, parms, diff_coeffs, adv_vel, solve_equilibrium, precipitation){
  
  with (as.list(parms),{
    
    # assign state variables
    i <- 1
    # state variables for solutes are total amounts,
    # but implicitly concentrations (total_amount/m³_pw)
    ALK     <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1 # -TOT_H
    DIC     <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1 # TOT_H2CO3
    TOT_P   <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    TOT_N5  <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    TOT_N3  <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    TOT_S6  <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    TOT_S2  <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    CH4     <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    O2      <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    N2      <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    Mn2     <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    Fe2     <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    # state variables for solids are tableau-species concentrations (mol/m3_svf)
    MnO2    <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    OM      <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    FeOH3   <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    FeOH3_P <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    FeCO3   <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    
    
    # transport terms
    tran.ALK     <- tran.1D(C = ALK, C.up = ALK_up, D = diff_coeffs$ALK, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.DIC     <- tran.1D(C = DIC, C.up = DIC_up, D = diff_coeffs$DIC, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.TOT_P   <- tran.1D(C = TOT_P, C.up = H2PO4_up, D = diff_coeffs$H2PO4, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.TOT_N5  <- tran.1D(C = TOT_N5, C.up = NO3_up, D = diff_coeffs$NO3, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.TOT_N3  <- tran.1D(C = TOT_N3, C.up = NH4_up, D = diff_coeffs$NH4, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.TOT_S6  <- tran.1D(C = TOT_S6, C.up = SO4_up, D = diff_coeffs$SO4, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.TOT_S2  <- tran.1D(C = TOT_S2, C.up = H2S_up, D = diff_coeffs$H2S, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.CH4     <- tran.1D(C = CH4, C.up = CH4_up, D = diff_coeffs$CH4, 
                            v = adv_vel$u, VF = grid.por, dx = grid)

    tran.O2      <- tran.1D(C = O2, C.up = O2_up, D = diff_coeffs$O2, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.N2      <- tran.1D(C = N2, C.up = N2_up, D = diff_coeffs$N2, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.Mn2     <- tran.1D(C = Mn2, C.up = Mn2_up, D = diff_coeffs$Mn2, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.Fe2     <- tran.1D(C = Fe2, C.up = Fe2_up, D = diff_coeffs$Fe2, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.MnO2    <- tran.1D(C = MnO2, flux.up = MnO2_up, D = diff_coeffs$solid, 
                            v = adv_vel$v, VF = grid.svf, dx = grid)
    
    tran.OM      <- tran.1D(C = OM, flux.up = OM_up, D = diff_coeffs$solid, 
                            v = adv_vel$v, VF = grid.svf, dx = grid)
    
    tran.FeOH3   <- tran.1D(C = FeOH3, flux.up = FeOH3_up, D = diff_coeffs$solid, 
                            v = adv_vel$v, VF = grid.svf, dx = grid)
    
    tran.FeOH3_P <- tran.1D(C = FeOH3_P, flux.up = FeOH3_P_up, D = diff_coeffs$solid, 
                            v = adv_vel$v, VF = grid.svf, dx = grid)
    
    tran.FeCO3   <- tran.1D(C = FeCO3, flux.up = FeCO3_up, D = diff_coeffs$solid, 
                            v = adv_vel$v, VF = grid.svf, dx = grid)
    
    
    # calculate solute equilibrium species (solve the tableau)
    if (solve_equilibrium) {
      # 1) grep the solute total components; here we need TOT_H = - ALK
      solute_totals <- c(-ALK, DIC, TOT_P, TOT_N5, TOT_N3, TOT_S6, TOT_S2)
      # 2) solve tableau
      solute_equilibrium  <- solve_tableau(solute_totals, tableau, logK, N_grid)
      # 3) assign results
      pH    <- -log10(solute_equilibrium$species_conc[,1] * 10^-3)
      OH    <- solute_equilibrium$species_conc[,2]
      H2CO3 <- solute_equilibrium$species_conc[,3]
      HCO3  <- solute_equilibrium$species_conc[,4]
      CO3   <- solute_equilibrium$species_conc[,5]
      H3PO4 <- solute_equilibrium$species_conc[,6]
      HPO4  <- solute_equilibrium$species_conc[,7]
      PO4   <- solute_equilibrium$species_conc[,8]
      HNO3  <- solute_equilibrium$species_conc[,9]
      NO3   <- solute_equilibrium$species_conc[,10]
      NH4   <- solute_equilibrium$species_conc[,11]
      NH3   <- solute_equilibrium$species_conc[,12]
      H2SO4 <- solute_equilibrium$species_conc[,13]
      HSO4  <- solute_equilibrium$species_conc[,14]
      SO4   <- solute_equilibrium$species_conc[,15]
      H2S   <- solute_equilibrium$species_conc[,16]
      HS    <- solute_equilibrium$species_conc[,17]
      S2    <- solute_equilibrium$species_conc[,18]
    } else {
      solute_equilibrium <- NA
    }
    
    
    # Precipitation Reactions
    if (precipitation & solve_equilibrium) {
      omega_siderite <- (Fe2 * CO3) / Ksp_siderite
    } else if (precipitation) {
      omega_siderite <- (Fe2 * DIC * 0.0001) / Ksp_siderite # !!!
    }
    else {
      omega_siderite <- rep(1, N_grid)
    }
    # Siderite: R7 = precipitation, R8 = dissolution
    R7 <- ifelse(omega_siderite > 1, k_precip_siderite * (omega_siderite - 1)^2, 0)
    R8 <- ifelse(omega_siderite < 1, k_diss_siderite * FeCO3 * (1 - omega_siderite)^2, 0)
    
    
    # FeOH3 fractions
    FeOH3_tot <- FeOH3 + FeOH3_P
    chi <- rep(1, length(FeOH3))
    ind_valid <- FeOH3_tot > 0
    chi[ind_valid] <- FeOH3[ind_valid] / FeOH3_tot[ind_valid]
    
    # limitation & inhibition terms
    L_O2    <- O2   / (K_O2 + O2)
    I_O2    <- K_O2 / (K_O2 + O2)
    
    L_NO3   <- TOT_N5 / (K_NO3 + TOT_N5)
    I_NO3   <- K_NO3 / (K_NO3 + TOT_N5)
    
    L_MnO2  <- MnO2   / (K_MnO2 + MnO2)
    I_MnO2  <- K_MnO2 / (K_MnO2 + MnO2)
    
    L_FeOH3 <- FeOH3_tot / (K_FeOH3 + FeOH3_tot)
    I_FeOH3 <- K_FeOH3 / (K_FeOH3 + FeOH3_tot)
    
    L_SO4   <- TOT_S6 / (K_SO4 + TOT_S6)
    I_SO4   <- K_SO4 / (K_SO4 + TOT_S6)
    
    L_H3PO4 <- TOT_P   / (K_H3PO4 + TOT_P)
    I_H3PO4 <- K_H3PO4 / (K_H3PO4 + TOT_P)
    
    # reaction rates
    R1 <- k_alpha * OM * L_O2
    R2 <- k_alpha * OM * L_NO3                            * I_O2
    R3 <- k_alpha * OM * L_MnO2                   * I_NO3 * I_O2
    R4 <- k_alpha * OM * L_FeOH3         * I_MnO2 * I_NO3 * I_O2
    R5 <- k_alpha * OM * L_SO4 * I_FeOH3 * I_MnO2 * I_NO3 * I_O2
    R6 <- k_alpha * OM * I_SO4 * I_FeOH3 * I_MnO2 * I_NO3 * I_O2
    
    # change of species concentration due to reactions
    ## solutes step1: change of slow-reaction-species (srs), the ones for which
    ## the reactions are formulated, according to reaction stoichiometry
    R.srs_O2    <- - s2p * R1                   # OM Degradation
    R.srs_CO2   <- (s2p * (R1 + R2 + R3 + R4 + R5 + 1/2 * R6)
                    - s2p * R7 + s2p * R8)  # Siderite Precipitation / Dissolution
    R.srs_NH3   <- OM_b * s2p * (R1 + R2 + R3 + R4 + R5 + R6)
    R.srs_H3PO4 <- s2p * ( OM_c * (R1 + R2 + R3 + R5 + R6) +
                      (OM_c + (1 - chi) * 4 * lambda) * R4 )
    R.srs_HNO3  <- - 4/5 * s2p * R2
    R.srs_N2    <- 2/5 * s2p * R2
    R.srs_FeOH2 <- (4 * s2p * R4                # OM degradation
                    - s2p * R7 + s2p * R8)  # Siderite Precipitation / Dissolution
    R.srs_MnOH2 <- 2 * s2p * R3
    R.srs_H2SO4 <- - 1/2 * s2p * R5
    R.srs_H2S   <- 1/2 * s2p * R5
    R.srs_CH4   <- 1/2 * s2p * R6
    
    ## solutes step2: change of tableau-components = model species
    ## translation of change of slow-reaction-species to change of 
    ## tableau components using the translation table
    ## here the component-total "H" is already converted to alkalinity (*-1)
    R.ALK   <- -1 * (- R.srs_NH3 + R.srs_H3PO4 + R.srs_HNO3 - 2 * R.srs_FeOH2
                     - 2 * R.srs_MnOH2 + 2 * R.srs_H2SO4)
    R.DIC    <- R.srs_CO2
    R.CH4    <- R.srs_CH4
    R.TOT_P  <- R.srs_H3PO4
    R.TOT_N5 <- R.srs_HNO3
    R.TOT_N3 <- R.srs_NH3
    R.TOT_S6 <- R.srs_H2SO4
    R.TOT_S2 <- R.srs_H2S
    R.O2     <- R.srs_O2
    R.N2     <- R.srs_N2
    R.Mn2    <- R.srs_MnOH2
    R.Fe2    <- R.srs_FeOH2
    
    ## solids
    R.OM <- - R1 - R2 - R3 - R4 - R5 - R6
    R.MnO2 <- - 2 * R3
    R.FeOH3 <- - 4 * chi * R4
    R.FeOH3_P <- - 4 * (1 - chi) * R4
    R.FeCO3 <- R7 - R8
    
    # total change in concentration of model species
    dCdt.ALK    <- R.ALK + tran.ALK$dC
    dCdt.DIC    <- R.DIC + tran.DIC$dC
    dCdt.CH4    <- R.CH4 + tran.CH4$dC
    dCdt.TOT_P  <- R.TOT_P + tran.TOT_P$dC
    dCdt.TOT_N5 <- R.TOT_N5 + tran.TOT_N5$dC
    dCdt.TOT_N3 <- R.TOT_N3 + tran.TOT_N3$dC
    dCdt.N2     <- R.N2  + tran.N2$dC
    dCdt.TOT_S6 <- R.TOT_S6 + tran.TOT_S6$dC
    dCdt.TOT_S2 <- R.TOT_S2 + tran.TOT_S2$dC
    dCdt.O2     <- R.O2 + tran.O2$dC
    dCdt.Mn2    <- R.Mn2 + tran.Mn2$dC
    dCdt.Fe2    <- R.Fe2 + tran.Fe2$dC
    dCdt.OM     <- R.OM + tran.OM$dC
    dCdt.MnO2   <- R.MnO2 + tran.MnO2$dC
    dCdt.FeOH3  <- R.FeOH3 + tran.FeOH3$dC
    dCdt.FeOH3_P <- R.FeOH3_P + tran.FeOH3_P$dC
    dCdt.FeCO3  <- R.FeCO3 + tran.FeCO3$dC
    
    # characteristic time scales
    # if dCdt.X = 0 -> timescale will be Inf
    time_scales <- c(
      ALK = ALK / dCdt.ALK,
      DIC = DIC / dCdt.DIC,
      CH4 = CH4 / dCdt.CH4,
      TOT_P = TOT_P / dCdt.TOT_P,
      TOT_N5 = TOT_N5 / dCdt.TOT_N5,
      TOT_N3 = TOT_N3 / dCdt.TOT_N3,
      N2 = N2 / dCdt.N2,
      TOT_S6 = TOT_S6 / dCdt.TOT_S6,
      TOT_S2 = TOT_S2 / dCdt.TOT_S2,
      O2 = O2 / dCdt.O2,
      Mn2 = Mn2 / dCdt.Mn2,
      Fe2 = Fe2 / dCdt.Fe2,
      OM = OM / dCdt.OM,
      MnO2 = MnO2 / dCdt.MnO2,
      FeOH3 = FeOH3 / dCdt.FeOH3,
      FeOH3_P = FeOH3_P / dCdt.FeOH3_P,
      FeCO3 = FeCO3 / dCdt.FeCO3
    )
    # but we need to take the absolute value to find the correct minimum
    time_scales <- abs(time_scales)
    # set NaN values to a number (???)
    time_scales[is.na(time_scales)] <- 100
    # set 0 to a small number
    time_scales[time_scales == 0] <- 1e-10

    return(
      list(
        c(
          dCdt.ALK = dCdt.ALK,
          dCdt.DIC = dCdt.DIC,
          dCdt.TOT_P = dCdt.TOT_P,
          dCdt.TOT_N5 = dCdt.TOT_N5,
          dCdt.TOT_N3 = dCdt.TOT_N3,
          dCdt.TOT_S6 = dCdt.TOT_S6,
          dCdt.TOT_S2 = dCdt.TOT_S2,
          dCdt.CH4 = dCdt.CH4,
          dCdt.O2 = dCdt.O2,
          dCdt.N2 = dCdt.N2,
          dCdt.Mn2 = dCdt.Mn2,
          dCdt.Fe2 = dCdt.Fe2,
          dCdt.MnO2 = dCdt.MnO2,
          dCdt.OM = dCdt.OM,
          dCdt.FeOH3 = dCdt.FeOH3,
          dCdt.FeOH3_P = dCdt.FeOH3_P,
          dCdt.FeCO3 = dCdt.FeCO3
        ),
        transport = list(
          tran.ALK = tran.ALK,
          tran.DIC = tran.DIC,
          tran.TOT_P = tran.TOT_P,
          tran.TOT_N5 = tran.TOT_N5,
          tran.TOT_N3 = tran.TOT_N3,
          tran.TOT_S6 = tran.TOT_S6,
          tran.TOT_S2 = tran.TOT_S2,
          tran.CH4 = tran.CH4,
          tran.O2 = tran.O2,
          tran.N2 = tran.N2,
          tran.Mn2 = tran.Mn2,
          tran.Fe2 = tran.Fe2,
          tran.MnO2 = tran.MnO2,
          tran.OM = tran.OM,
          tran.FeOH3 = tran.FeOH3,
          tran.FeOH3_P = tran.FeOH3_P,
          tran.FeCO3 = tran.FeCO3
        ),
        sumR = list(
          R.ALK     = R.ALK * grid.por$mid,
          R.DIC     = R.DIC * grid.por$mid,
          R.TOT_P   = R.TOT_P * grid.por$mid,
          R.TOT_N5  = R.TOT_N5 * grid.por$mid,
          R.TOT_N3  = R.TOT_N3 * grid.por$mid,
          R.TOT_S6  = R.TOT_S6 * grid.por$mid,
          R.TOT_S2  = R.TOT_S2 * grid.por$mid,
          R.CH4     = R.CH4 * grid.por$mid,
          R.O2      = R.O2 * grid.por$mid,
          R.N2      = R.N2 * grid.por$mid,
          R.Mn2     = R.Mn2 * grid.por$mid,
          R.Fe2     = R.Fe2 * grid.por$mid,
          R.MnO2    = R.MnO2 * grid.svf$mid,
          R.OM      = R.OM * grid.svf$mid,
          R.FeOH3   = R.FeOH3 * grid.svf$mid,
          R.FeOH3_P = R.FeOH3_P * grid.svf$mid,
          R.FeCO3   = R.FeCO3 * grid.svf$mid
        ),
        rates = list(
          R1 = R1 * grid.svf$mid,
          R2 = R2 * grid.svf$mid,
          R3 = R3 * grid.svf$mid,
          R4 = R4 * grid.svf$mid,
          R5 = R5 * grid.svf$mid,
          R6 = R6 * grid.svf$mid,
          R7 = R7 * grid.svf$mid,
          R8 = R8 * grid.svf$mid
        ),
        solute_equilibrium = solute_equilibrium,
        time_scales = time_scales,
        omega_siderite = omega_siderite,
        timescale_Fe2 = Fe2 / dCdt.Fe2,
        dCdt_Fe2 = dCdt.Fe2
      )
    )
 })
}
```


## Solve Model

### Step 1) Steady State without Speciation

Solve steady state without equilibrium solver.
Precipitation reactions are controlled by component-totals.

```{r std1}
#| echo: true

initial <- rep(1e-4, N_grid * N_species)

std1 <- steady.1D(
  y = initial,
  func = model,
  parms = parameter, 
  dimens = N_grid,
  nspec = N_species,
  names = model_species,
  positive = TRUE,
  method = "stodes",
  diff_coeffs = diffusion_coefficients,
  adv_vel = advective_velocities,
  solve_equilibrium = FALSE,
  precipitation = TRUE
)
```

The speciation is calculated for the resulting steady-state.

```{r std1 speciation}
#| echo: true

# the first 7 model-species are tableau components
# In the model we have alkalinity (column 1) - but here we need TOT_H = -ALK
component_total <- c(-1*std1$y[,1], std1$y[,2:7])

microbenchmark(
  equilibrium  <- solve_tableau(component_total, tableau, logK, N_grid),
  times = 1
)

# Check "success" state for every layer
## 0 = at least one total_component differs more than 1e-12 (atol)
## 1 = atol reached at first try with pcfm
## 2 = atol reached at first try with newton
## 3 = atol reached at second try with pcfm
## 4 = atol reached at second try with newton
## 5 = atol reached at third try with pcfm
table(equilibrium$success)

# Check for NA results, indicating something went wrong
sum(is.na(equilibrium$species_conc))
```

#### Profiles: Component-Totals

```{r plot std1}
#| column: screen-inset
#| layout-ncol: 5
#| fig.height: 3.5
#| fig.width: 3.5

plot_std_profiles(std1)
```

#### Profiles: Speciation

```{r plot std1 speciation}
#| column: screen-inset
#| layout-ncol: 3
#| fig.width: 6

speciation <- equilibrium$species_conc
colnames(speciation) <- tableau_species

rcols <- viridis::viridis(6)

matplot(y=grid$x.mid, x = speciation[,3:5],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6], rcols[1]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("H2CO3", "HCO3", "CO3"),
  lty = 1,
  col = c(rcols[3], rcols[6], rcols[1]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,6:9],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6], rcols[1], rcols[4]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("H3PO4", "H2PO4-", "HPO42-", "PO43-"),
  lty = 1,
  col = c(rcols[3], rcols[6], rcols[1], rcols[4]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,10:11],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("HNO3", "NO3-"),
  lty = 1,
  col = c(rcols[3], rcols[6]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,12:13],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("NH4+", "NH3"),
  lty = 1,
  col = c(rcols[3], rcols[6]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,14:16],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6], rcols[1]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("H2SO4", "HSO4-", "SO42-"),
  lty = 1,
  col = c(rcols[3], rcols[6], rcols[1]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,17:19],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6], rcols[1]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("H2S", "HS-", "S2-"),
  lty = 1,
  col = c(rcols[3], rcols[6], rcols[1]),
  lwd = 2
)
```

#### Profile: pH

```{r plot pH}
#| out.width: 100%

pH <- -log10(speciation[,1] * 10^-3)
plot(grid$x.mid ~ pH, ylim = c(0.1, 0), type = "l", ylab = "depth (m)", lwd = 2)
```

#### Profiles: Saturation

```{r plot saturation}
#| out.width: 100%

rcols <- viridis::viridis(2)

omega_siderite <- speciation[,"CO3"] * std1$y[, "Fe2"] / parameter$Ksp_siderite

plot(
    x = omega_siderite,
    y = grid$x.mid,
    ylim = c(max(grid$x.int), min(grid$x.int)),
    xlim = c(min(std1$omega_siderite, omega_siderite), max(std1$omega_siderite, omega_siderite)),
    type = "l",
    lwd = 2,
    col = rcols[1],
    xlab = "omega siderite",
    ylab = "depth (m)",
    log = "x"
  )

points(
    x = std1$omega_siderite,
    y = grid$x.mid,
    type = "l",
    lwd = 2,
    col = rcols[2]
  )

legend("bottomright", c("with CO32-", "with DIC * 0.1"), col = rcols, lwd = 2)
```

#### Profiles: Reaction Rates

```{r plot rates}
#| out.width: 100%

plot_std_rates(std1)
```


### Step 2) Steady State with Speciation

Solve steady state with equilibrium solver.
Precipitation reactions are controlled by the actual species concentrations.

```{r def Runge-Kutta}
#| echo: true
#| code-fold: show

# Runge-Kutta Method
rk <- function(func, x0, y0, maxsteps, stol = 1e-8, nrow_concs, names, N_grid, tableau_species, ...) {
  
  times <- c()
  h_log <- c()
  concs <- matrix(ncol = maxsteps+1, nrow = nrow_concs)
  omega_siderite <- matrix(ncol = maxsteps+1, nrow = N_grid)
  tran.Fe2 <- matrix(ncol = maxsteps+1, nrow = N_grid)
  timescale.Fe2 <- matrix(ncol = maxsteps+1, nrow = N_grid)
  dCdt.Fe2 <- matrix(ncol = maxsteps+1, nrow = N_grid)

  for (i in seq(maxsteps+1)) {
    
    # calculate model at current time
    model_return <- func(x0, y0, ...)
    
    # set integration timestep
    h <- min(model_return$time_scales) * 0.05
    # maximum timestep: 1e-6
    h <- min(h, 1e-6)
    
    # logging
    if (i == 1) {
      rates <- as.data.frame(model_return$rates)
      speciation <- model_return$solute_equilibrium$species_conc
    } else {
      rates <- rbind(rates, as.data.frame(model_return$rates))
      speciation <- rbind(speciation, model_return$solute_equilibrium$species_conc)
    }
    
    times[i]  <- x0
    h_log[i]  <- h
    concs[,i] <- y0
    omega_siderite[,i] <- model_return$omega_siderite
    tran.Fe2[,i] <- model_return$transport$tran.Fe2$dC
    dCdt.Fe2[,i] <- model_return$dCdt_Fe2
    timescale.Fe2[,i] <- model_return$timescale_Fe2
    
    dCdt  <- model_return[[1]]
    
    # check if to break loop
    #if (mean(abs(dCdt)) < stol) break
    
    # 1st order R-K method
    x0 <- x0 + h
    y0 <- y0 + h * dCdt
    
    y0[y0 < 0] <- 0
  
  }
  
  concs_split <- list()
  for (j in seq_len(length(names))) {
    concs_split[[j]] <- concs[((j-1) * N_grid + 1) : (j * N_grid),]
  }
  names(concs_split) <- names
  
  rates_split <- list()
  for (j in seq_len(ncol(rates))) {
    rates_split[[j]] <- matrix(rates[,j], ncol = i)
  }
  names(rates_split) <- colnames(rates)
  
  speciation_split <- list()
  for (j in seq_len(ncol(speciation))) {
    speciation_split[[j]] <- matrix(speciation[,j], ncol = i)
  }
  names(speciation_split) <- tableau_species
  
  return(list(
    # method log
    times = times,
    h = h_log,
    # output of final step according to steady.1D
    y = matrix(y0, nrow = N_grid, byrow = FALSE),
    transport = model_return$transport,
    sumR = model_return$sumR,
    rates = model_return$rates,
    solute_equilibrium = model_return$solute_equilibrium,
    time_scales = model_return$time_scales,
    # time series output
    concs_split = concs_split,
    rates_split = rates_split,
    speciation_split = speciation_split,
    # to be cleaned up ...
    omega_siderite = omega_siderite,
    timescale.Fe2 = timescale.Fe2,
    tran.Fe2 = tran.Fe2,
    dCdt.Fe2 = dCdt.Fe2,
    dCdt = dCdt
  ))
}
```

```{r std3}
#| echo: true
std3 <- steady.1D( # !!!
  y = std1$y,
  func = model,
  parms = parameter,
  dimens = N_grid,
  nspec = N_species,
  names = model_species,
  positive = TRUE,
  method = "stode",
  maxiter = 100,
  diff_coeffs = diffusion_coefficients,
  adv_vel = advective_velocities,
  solve_equilibrium = TRUE,
  precipitation = TRUE
)
```

```{r std2}
#| echo: true

timesteps <- 200

std2 <- rk(
  func = model,
  x0 = 0,
  y0 = as.vector(std3$y), # !!!
  maxsteps = timesteps,
  stol = 1e-8,
  nrow_concs = length(model_species) * N_grid,
  names = model_species,
  N_grid = N_grid,
  tableau_species = tableau_species,
  parms = parameter,
  diff_coeffs = diffusion_coefficients,
  adv_vel = advective_velocities,
  solve_equilibrium = TRUE,
  precipitation = TRUE
)
```

#### Development of integration timestep h

```{r plot h development}
#| echo: false
#| out.width: 100%

plot(
  x = seq_along(std2$h),
  y = std2$h, type = "b",
  xlab = "timestep n",
  ylab = "integration timestep h"
)
```

#### Concentration Profiles

Concentrations at different timesteps over depth (solid black is the first one).
```{r}
#| column: screen-inset
#| layout-ncol: 3
#| fig.width: 6

for (species in model_species) {
  plot_std_conc_evolution(std2$concs_split, species, 25, grid)
}

matplot(
  y = grid$x.mid,
  x = -log10(std2$speciation_split$H),
  ylim = c(0.1, 0),
  type = "l"
)
```

#### Reaction Rate Development

Reaction rates in different layers over time.
```{r}
#| column: screen-inset
#| layout-ncol: 3
#| fig.width: 6

for (rate in names(std2$rates)) {
  plot_std_rate_evolution(std2, rate, 50)
}
```

#### Problem Analysis

```{r, fig.width=10, fig.height=10, echo=FALSE}
#| eval: FALSE

par(mfrow = c(2, 2))

#spots <- seq(1, max_steps, 5)
spots <- seq(max_steps-5, max_steps, 1)

omega_sid <- std2$omega_siderite[, spots]
omega_sid2 <- ifelse(omega_sid>1, (omega_sid-1)^2, -(omega_sid-1)^2)
xlim1 <- c(0,50)
matplot(
  omega_sid,
  type = "l",
  #log = "y",
  ylim = c(-1,30),
  xlim = xlim1,
  main = "omega siderite"
)

matplot(
  omega_sid2,
  type = "l",
  #log = "y",
  #ylim = c(-1,2),
  xlim = xlim1,
  main = "(omega siderite-1)^2*sign"
)

matplot(
  std2$concs_split$Fe2[, spots],
  type = "l",
  #log = "y",
  xlim = xlim1,
  main = "Fe2"
)

matplot(
  std2$CO3[, spots],
  type = "l",
  log = "y",
  main = "CO3"
)

#matplot(
#  std2$concs_split$FeCO3[, spots],
#  type = "l",
#  log = "y",
#  main = "FeCO3"
#)

plot_std_omega_evolution <- function(data, N_lines, grid) {
  
  # number of available timesteps
  available_timesteps <- ncol(data)
  
  # selection of N_lines timesteps
  selected_timesteps <- floor(seq.int(1, available_timesteps, length.out = N_lines))
  
  # plot
  matplot(y = grid$x.mid,
          x = data,
          type = "l",
          ylim = c(max(grid$x.mid), min(grid$x.mid)),
          xlab = "concentration (mol/m^3_phase)",
          ylab = "depth (m)",
          log = "x",
          main = "omega siderite")
}

#plot_std_omega_evolution(std2$omega_siderite, 100, grid)
```


::: {layout-ncol="2"}
```{r}
#| eval: FALSE

sliderInput("steps", "Time steps:", width = "500px", min = 1, max = timesteps, value = c(1, timesteps))
```

```{r}
#| eval: FALSE

sliderInput("depth", "Depth:", width = "500px", min = round(min(grid$x.mid), 3), max = round(max(grid$x.mid), 3), value = c(round(min(grid$x.mid), 3), round(max(grid$x.mid), 3)))
```
:::

```{r}
#| eval: FALSE
#| column: screen-inset
#| layout-ncol: 4

#plotOutput("plotOmega", height = "550px")
plotOutput("plotOmega2", height = "550px")
plotOutput("plotFe2", height = "550px")
plotOutput("plotFeCO3", height = "550px")
plotOutput("plotPrecip", height = "550px")
plotOutput("plotDiss", height = "550px")
plotOutput("plotR4", height = "550px")
plotOutput("plotTran.Fe2", height = "550px")
plotOutput("plotdCdt.Fe2", height = "550px")
#plotOutput("plottimescale.Fe2", height = "550px")
```

```{r}
#| eval: FALSE
#| context: data

timesteps <- timesteps
std <- std2
grid <- grid
omega_sid <- std$omega_siderite
omega_sid2 <- ifelse(omega_sid>1, (omega_sid-1)^2, -(omega_sid-1)^2)
s2p <- conversion_factors$s2p
```

```{r}
#| eval: FALSE
#| context: server

index_depth <- reactive({grid$x.mid > input$depth[1] & grid$x.mid < input$depth[2]})

output$plotOmega <- renderPlot({
  timespots <- seq(input$steps[1], input$steps[2], 1)
  matplot(
    x = omega_sid[index_depth(), timespots],
    y = grid$x.mid[index_depth()],
    type = "l",
    lwd = 2,
    ylim = c(input$depth[2], input$depth[1]),
    main = "omega siderite"
  )
  },
  res = 120
)

output$plotOmega2 <- renderPlot({
  timespots <- seq(input$steps[1], input$steps[2], 1)
  matplot(
    x = omega_sid2[index_depth(), timespots] + 1,
    y = grid$x.mid[index_depth()],
    type = "l",
    lwd = 2,
    ylim = c(input$depth[2], input$depth[1]),
    log = "x",
    main = "omega siderite^2"
  )
  },
  res = 120
)

output$plotFe2 <- renderPlot({
  timespots <- seq(input$steps[1], input$steps[2], 1)
  matplot(
    x = std$concs_split$Fe2[index_depth(), timespots],
    y = grid$x.mid[index_depth()],
    type = "l",
    lwd = 2,
    ylim = c(input$depth[2], input$depth[1]),
    main = "Fe2"
  )
  },
  res = 120
)

output$plotFeCO3 <- renderPlot({
  timespots <- seq(input$steps[1], input$steps[2], 1)
  matplot(
    x = std$concs_split$FeCO3[index_depth(), timespots],
    y = grid$x.mid[index_depth()],
    type = "l",
    lwd = 2,
    ylim = c(input$depth[2], input$depth[1]),
    main = "FeCO3"
  )
  },
  res = 120
)

output$plotPrecip <- renderPlot({
  timespots <- seq(input$steps[1], input$steps[2], 1)
  matplot(
    x = cbind(std$rates_split$R4[index_depth(), 1] * 4, std$rates_split$R7[index_depth(), timespots]),
    y = grid$x.mid[index_depth()],
    type = "l",
    lwd = 2,
    ylim = c(input$depth[2], input$depth[1]),
    main = "Precipitation"
  )
  },
  res = 120
)

output$plotR4 <- renderPlot({
  timespots <- seq(input$steps[1], input$steps[2], 1)
  matplot(
    x = std$rates_split$R4[index_depth(), timespots] * 4,
    y = grid$x.mid[index_depth()],
    type = "l",
    lwd = 2,
    ylim = c(input$depth[2], input$depth[1]),
    main = "R4"
  )
  },
  res = 120
)

output$plotDiss <- renderPlot({
  timespots <- seq(input$steps[1], input$steps[2], 1)
  matplot(
    x = std$rates_split$R8[index_depth(), timespots],
    y = grid$x.mid[index_depth()],
    type = "l",
    lwd = 2,
    ylim = c(input$depth[2], input$depth[1]),
    main = "Dissolution"
  )
  },
  res = 120
)

output$plotTran.Fe2 <- renderPlot({
  timespots <- seq(input$steps[1], input$steps[2], 1)
  matplot(
    x = std$tran.Fe2[index_depth(), timespots],
    y = grid$x.mid[index_depth()],
    type = "l",
    lwd = 2,
    ylim = c(input$depth[2], input$depth[1]),
    main = "Transport Fe2"
  )
  },
  res = 120
)

output$plotdCdt.Fe2 <- renderPlot({
  timespots <- seq(input$steps[1], input$steps[2], 1)
  matplot(
    x = std$dCdt.Fe2[index_depth(), timespots],
    y = grid$x.mid[index_depth()],
    type = "l",
    lwd = 2,
    ylim = c(input$depth[2], input$depth[1]),
    main = "dCdt Fe2"
  )
  },
  res = 120
)

output$plottimescale.Fe2 <- renderPlot({
  timespots <- seq(input$steps[1], input$steps[2], 1)
  matplot(
    x = std$timescale.Fe2[index_depth(), timespots],
    y = grid$x.mid[index_depth()],
    type = "l",
    lwd = 2,
    ylim = c(input$depth[2], input$depth[1]),
    main = "timescale Fe2"
  )
  },
  res = 120
)
```

#### Profiles: Speciation

```{r}
#| column: screen-inset
#| layout-ncol: 3
#| fig.width: 6

speciation <- std2$solute_equilibrium$species_conc
colnames(speciation) <- tableau_species

rcols <- viridis::viridis(6)

matplot(y=grid$x.mid, x = speciation[,3:5],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6], rcols[1]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("H2CO3", "HCO3", "CO3"),
  lty = 1,
  col = c(rcols[3], rcols[6], rcols[1]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,6:9],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6], rcols[1], rcols[4]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("H3PO4", "H2PO4-", "HPO42-", "PO43-"),
  lty = 1,
  col = c(rcols[3], rcols[6], rcols[1], rcols[4]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,10:11],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("HNO3", "NO3-"),
  lty = 1,
  col = c(rcols[3], rcols[6]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,12:13],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("NH4+", "NH3"),
  lty = 1,
  col = c(rcols[3], rcols[6]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,14:16],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6], rcols[1]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("H2SO4", "HSO4-", "SO42-"),
  lty = 1,
  col = c(rcols[3], rcols[6], rcols[1]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,17:19],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6], rcols[1]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("H2S", "HS-", "S2-"),
  lty = 1,
  col = c(rcols[3], rcols[6], rcols[1]),
  lwd = 2
)
```

#### Profile: pH

```{r}
#| out.width: 100%

pH <- -log10(speciation[,1] * 10^-3)
plot(grid$x.mid ~ pH, ylim = c(0.1, 0), type = "l", ylab = "depth (m)", lwd = 2)
```



## Mass Balances

### Species-based Mass Balances

The change in concentration of a species $i$, integrated over depth and in relation to the area $A$ is

$$\frac{dC_{A,i}}{dt} \; \left( \frac{mol}{m^2 \cdot a} \right) = J(a)_i - J(b)_i + \int_{a}^b \Psi \sum R_i$$

with

- $J(a)_i$: flux of species $i$ across upper boundary
- $J(b)_i$: flux of species $i$ across lower boundary
- $\Psi$: volume fraction.

```{r std species-based mass balances}
#| echo: false

species_mass_balance <- function(species_vector, std, grid) {
  
  species_mass_balance_inner <- function(species, std, grid) {
  
    tran.species <- paste0("tran.", species)
    flux_up   <- std$transport[[tran.species]]$flux.up
    flux_down <- std$transport[[tran.species]]$flux.down
    netto_flux <- flux_up - flux_down
    
    R.species <- paste0("R.", species)
    sumR_integrated <- sum(std$sumR[[R.species]] * grid$dx)
    
    bilanz <- netto_flux + sumR_integrated
    
    return(data.frame(
      species = species,
      flux_up = flux_up,
      flux_down = flux_down,
      netto_flux = netto_flux,
      sumR_integrated = sumR_integrated,
      bilanz = bilanz
    ))
  }
  
  species_based_mass_balance <- data.frame(
  "Species" = NULL,
  "Flux up" = NULL,
  "Flux down" = NULL,
  "Netto Flux" = NULL,
  "integral sum R" = NULL,
  "Bilanz" = NULL
  )
  
  for (species in species_vector) {
    species_based_mass_balance <- rbind(
      species_based_mass_balance,
      species_mass_balance_inner(species, std, grid)
    )
  }
  
  return(species_based_mass_balance)
}

species_mass_balance_std1 <- species_mass_balance(model_species, std1, grid)
species_mass_balance_std2 <- species_mass_balance(model_species, std2, grid)
species_mass_balance_std3 <- species_mass_balance(model_species, std3, grid)

knitr::kable(
  species_mass_balance_std1,
  caption = "std1",
  digits = 20,
  format.args = list(format = "e", digits = 2)
)
knitr::kable(
  species_mass_balance_std2,
  caption = "std2",
  digits = 20,
  format.args = list(format = "e", digits = 2)
)
knitr::kable(
  species_mass_balance_std3,
  caption = "std3",
  digits = 20,
  format.args = list(format = "e", digits = 2)
)
```


### Element-based Mass Balances
