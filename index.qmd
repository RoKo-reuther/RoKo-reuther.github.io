---
title: "Fe Treatment Model"

execute:
  echo: false
  eval: true

bibliography: FeTreatment.bib
---

```{r load libraries}
#| message: false

require(readODS)
require(marelac)
require(ReacTran)
require(microbenchmark)
require(plotly)
```

## Concept

### Reactions

Reactions affect solute and solid model species differently.

The solid model species are the same occurring in the chemical reaction equations.
Therefore they are affected directly according to the reaction stoichiometry.

Solute model species are either component-totals (e.g. DIC, TOT_P, ...) to be speciated later or species on their own (e.g. O2, CH4).
The effect of reactions on solute species is first formulated for the species occurring in the chemical reaction equations according to the reaction stoichiometry.
In a second step this changes are translated to changes of the component-totals / model species using a translation table.

### Transport

For solutes the (probably) dominant species of a component-total governs the diffusion coefficient (cf code-block "Diffusion Coefficients").
The transport of solids is not affected by species properties.


## Reactions Describing OM Decomposition

### OM Composition

$\ce{(CH2O)_a (NH3)_b (H3PO4)_c}$

- $a = 1$
- $b = 16/106$
- $c = 1/106$


### Rate Constants

- $k_{\alpha} = 0.05 - 1.62 \: yr^{-1}$    [@moodley2005; @tromp1995global]
- $k_{\beta} = 0.025 - 0.0086 \: yr^{-1}$  [@tromp1995global]


### Limitation (L) and Inihibition (I) Terms

#### O2

$L_{\ce{O2}} = \frac{[\ce{O2}]}{K_{\ce{O2}} + [\ce{O2}]}$

$I_{\ce{O2}} = \frac{K_{\ce{O2}}}{K_{\ce{O2}} + [\ce{O2}]}$

with $K_{O2} = 0.001 - 0.03 \: mol \: m^{-3}_{pw}$ [@wang1996multicomponent]

#### NO3-

$L_{\ce{NO3^-}} = \frac{[\ce{NO3^-}]}{K_{\ce{NO3-}} + [\ce{NO3^-}]}$

$I_{\ce{NO3^-}} = \frac{K_{\ce{NO3^-}}}{K_{\ce{NO3^-}} + [\ce{NO3^-}]}$

with $K_{NO3-} = 0.004 - 0.08  \: mol \: m^{-3}_{pw}$ [@wang1996multicomponent]

#### MnO2

$L_{\ce{MnO2^{\alpha}}} = \frac{[\ce{MnO2^{\alpha}}]}{K_{\ce{MnO2}} + [\ce{MnO2^{\alpha}}]}$
 
$I_{\ce{MnO2^{\alpha}}} = \frac{K_{\ce{MnO2}}}{K_{\ce{MnO2}} + [\ce{MnO2^{\alpha}}]}$

with $K_{\ce{MnO2^{\alpha}}} = \{0.004 - 0.032\} \: mol \: {kg}^{-1} \cdot \rho_{dry}$  [@wang1996multicomponent]

#### Fe(OH)3

$L_{\ce{Fe(OH)3_{; tot}^\alpha}} = \frac{[\ce{Fe(OH)3_{; tot}^\alpha}]}{K_{\ce{Fe(OH)3}} + [\ce{Fe(OH)3_{; tot}^\alpha}]}$

$I_{\ce{Fe(OH)3^\alpha}} = \frac{K_{\ce{Fe(OH)3}}}{K_{\ce{Fe(OH)3}} + [\ce{Fe(OH)3_{; tot}^\alpha}]}$

with $K_{\ce{FeOH3}} = \{0.065 - 0.1\} \: mol \: {kg}^{-1} \cdot \rho_{dry}$ [@wang1996multicomponent]

#### SO42-

$L_{\ce{SO4^{2-}}} = \frac{[\ce{SO4^{2-}}]}{K_{\ce{SO4^{2-}}} + [\ce{SO4^{2-}}]}$

$I_{\ce{SO4^{2-}}} = \frac{K_{\ce{SO4^{2-}}}}{K_{\ce{SO4^{2-}}} + [\ce{SO4^{2-}}]}$

with $K_{SO42-} = 0.0016  \: mol \: {m^{-3}_{pw}}$ [@wang1996multicomponent]

#### H3PO4

$L_{\ce{H3PO4}} = \frac{[\ce{H3PO4}]}{K_{\ce{H3PO4}} + [\ce{H3PO4}]}$

with $K_{\ce{H3PO4}} = 10^{-5} \: mol \: m^{-3}_{pw}$ (Reinier)

> formulated for lump sum

### FeOH3 Fractions

$\ce{Fe(OH)3_{; tot}^\alpha} = \ce{Fe(OH)3^{\alpha}} + \ce{Fe(OH)3^\alpha(H3PO4)_{\lambda}}$ with $\lambda = 0.6$

$\chi = \frac{[\ce{Fe(OH)3^{\alpha}}]}{[\ce{Fe(OH)3_{; tot}^\alpha}]}$


### Reactions

#### OM + O2 (R1)

$\ce{OM^{\alpha, \beta} + O2 -> CO2 + b NH3 + c H3PO4 + H2O}$

$R = k_{\alpha, \beta} \: OM^{\alpha, \beta} \: L_{\ce{O2}}$


#### OM + HNO3 (R2)

$\ce{OM^{\alpha, \beta} + 4/5 HNO3 -> CO2 + b NH3 + c H3PO4 + 2/5 N2 + 7/5 H2O}$

$R = k_{\alpha, \beta} \: OM^{\alpha, \beta} \: L_{\ce{NO3-}} \: I_{\ce{O2}}$


#### OM + MnO2 (R3)

$\ce{OM^{\alpha, \beta} + 2 MnO2 + H2O -> CO2 + b NH3 + c H3PO4 + 2 Mn(OH)2}$

$R = k_{\alpha, \beta} \: OM^{\alpha, \beta} \: L_{\ce{MnO2}^\alpha} \: I_{\ce{NO3^-}} \: I_{\ce{O2}}$


#### OM + FeOH3 / FeOH3~H3PO4 (R4)

$\ce{OM^{\alpha, \beta} + 4 (\chi Fe(OH)3^{\alpha} + (1 - \chi) Fe(OH)3^\alpha(H3PO4)_{\lambda} ) -> CO2 + b NH3 + (c + (1- \chi) 4 \lambda) H3PO4 + 4 Fe(OH)2 + 3 H2O}$

$R = k_{\alpha, \beta} \: OM^{\alpha, \beta} \: L_{\ce{Fe(OH)3_{; tot}^\alpha}} \: I_{\ce{MnO2^{\alpha}}} \: I_{\ce{NO3^-}} \: I_{\ce{O2}}$


#### OM + H2SO4 (R5)

$\ce{OM^{\alpha, \beta} + 1/2 H2SO4 -> CO2 + b NH3 + c H3PO4 + 1/2 H2S + H2O}$

$R = k_{\alpha, \beta} \: OM^{\alpha, \beta} \: L_{\ce{SO4^{2-}}} \: I_{\ce{Fe(OH)3^\alpha}} \: I_{\ce{MnO2^{\alpha}}} \: I_{\ce{NO3^-}} \: I_{\ce{O2}}$


#### Methanogenesis (R6)

$\ce{OM^{\alpha, \beta} -> 1/2 CO2 + b NH3 + c H3PO4 + 1/2 CH4}$

$R = k_{\alpha, \beta} \: OM^{\alpha, \beta} \: I_{\ce{SO4^{2-}}} \: I_{\ce{Fe(OH)3^\alpha}} \: I_{\ce{MnO2^{\alpha}}} \: I_{\ce{NO3^-}} \: I_{\ce{O2}}$


## Redox Precipitation / Dissolution Reactions

### FeOH3 / FeOH3~H3PO4-Reduction coupled to Sulphide Oxidation (R9)

$\ce{2 ( \chi Fe(OH)3^{\alpha} + (1-\chi) Fe(OH)3^{\alpha}(H3PO4)_{\lambda} ) + H2S -> 2 Fe(OH)_2 + S^0 + 2 H2O + 2 (1 - \chi) \lambda H3PO4}$

$R = k \: [\ce{Fe(OH)3_{; tot}^{\alpha}}] \: [\ce{\sum H2S}] \quad (mol \: {m_{sf}}^{-3} \: yr^{-3})$

with $k \leqq 10^2 \: {m_{pw}}^3 \: mol^{-1} \: yr^{-1}$ [@wang1996multicomponent]

| unit correct???

### FeOH3 / FeOH3~H3PO4-Formation (R10)

$\ce{O2 + 4 Fe(OH)_2 + 2 H2O + 4 L_{\ce{H3PO4}} \lambda H3PO4 -> 4 ( (1 - L_{\ce{H3PO4}}) Fe(OH)3^{\alpha} + L_{\ce{H3PO4}} Fe(OH)3^{\alpha}(H3PO3)_{\lambda} )}$

$R = k \: [\ce{O2}] \: [\ce{Fe^{2+}}]$
 
with $k = 1.4 \times 10^5 \: {m_{pw}}^3 \: mol^{-1} \: yr^{-1}$ [@wang1996multicomponent]


## Precipitation Reactions

### Siderite Precipitation (R7) / Dissolution (R8)

In general:

$\ce{FeCO3 <-> Fe^{2+} + CO3^{2-}}$

In our model:

$\ce{FeCO3 + 2 H2O <-> Fe(OH)2 + H2CO3}$

Precipitation and Dissolution are split in two reactions from which only one is active at a time, depending on the saturation state $\Omega$.

$\Omega = \frac{\ce{[Fe^{2+}]} \cdot \ce{[CO3^{2-}]}}{K_{sp; siderite}} \quad$
with $\quad K_{sp; siderite} = 10^{-10.4} \cdot 1000^2 \; mol^2 \; m^{-6}$

If $\: \Omega > 1$:

- $R_{precipitation} = k_{precip} \cdot (\Omega - 1)^2 \quad$
with $\quad k_{precip} \approx 1.8 \times 10^{2} \; mol \; {m_{sf}}^{-3} \; yr^{-1}$
- $R_{dissolution} = 0$

If $\: \Omega < 1$:

- $R_{precipitation} = 0$
- $R_{dissolution} = - k_{diss} \cdot \ce{[FeCO3]} \cdot (\Omega - 1)^2 \quad$
with $\quad k_{diss} \approx 2.5 \times 10^{-1} \; yr^{-1}$


## Equilibrium Reactions described via Tableau

```{r read tableau}
excel <- read_fods("tableau.fods", sheet = "morel_tableau")

tableau_print <- as.data.frame(excel)

excel[is.na(excel)] <- 0

column_H2O  <- 2
column_logK <- 10
column_species_names <- 1
row_H2O     <- 1

tableau <- as.matrix(excel[-row_H2O,-c(column_H2O, column_logK, column_species_names)])

logK <- as.vector(unlist(excel[-row_H2O, column_logK]))

tableau_species <- unlist(excel[,column_species_names])[-1]
names(tableau_species) <- NULL

model_species <- c("ALK", "DIC", "TOT_P", "TOT_N5", "TOT_N3", "TOT_S6", "TOT_S2", "CH4", "O2", "N2", "Mn2", "Fe2", "MnO2", "OM", "FeOH3", "FeOH3_P", "FeCO3", "S0")

#excel <- read_xlsx("tableau.xlsx", sheet = "translation_table")
#excel[is.na(excel)] <- 0

rm(column_H2O, column_logK, column_species_names, row_H2O, excel)
```

The Tableau is used to calculate equilibrium speciation of solute species after model run.
Fast equilibrium reactions are neglected during model runtime (so far).

```{r print tableau}
options(knitr.kable.NA = '')
knitr::kable(tableau_print)
```


## Functions

### Solve Tableau

```{r def solve_tableau}
#| echo: true
#| code-fold: true

solve_tableau <- function(component_total, tableau, logK, N_grid) {
  
  # load shared object
  dyn.load("solve_tableau.so")

  return(.Fortran("solve_tableau",
                  component_total = as.double(component_total),
                  tableau         = matrix(as.double(tableau), ncol = ncol(tableau)),
                  logK            = as.double(logK),
                  N_components    = as.integer(ncol(tableau)),
                  N_species       = as.integer(nrow(tableau)),
                  N_grid          = as.integer(N_grid),
                  iter_pcfm       = rep(as.integer(0), N_grid),
                  iter_newton     = rep(as.integer(0), N_grid),
                  info_newton     = rep(as.integer(0), N_grid),
                  difference      = matrix(as.double(0), ncol = ncol(tableau), nrow = N_grid),
                  species_conc    = matrix(as.double(0), ncol = nrow(tableau), nrow = N_grid),
                  success         = rep(as.integer(0), N_grid)
                  )
  )
  
}
```

### Plot steady.1D results

```{r def plot functions 1}
#| echo: true
#| code-fold: true

plot_std_profiles <- function(std) {
  
  plot(std, xyswap = TRUE, xlab = "mol/m3_phase", ylab = "depth (m)",
       grid = grid$x.mid,
       which = model_species,
       lwd = 2,
       cex = 1.5,
       mfrow = c(1,1)
  )
}

plot_std_rates <- function(std, reactions, title = "") {
  
  # rcols <- viridis::viridis(length(std$rates))
  # 
  # matplot(y = grid$x.mid,
  #         x = as.data.frame(std$rates),
  #         type = "l", lwd=2, lty=1,
  #         ylim = c(length,0), 
  #         col = rcols,
  #         ylab="depth (m)", 
  #         xlab="reaction rate (mol/(m3_bulk yr))")
  # 
  # legend(
  #   x = "bottomright",
  #   legend = names(std$rates),
  #   lty = 1,
  #   col = rcols <- viridis::viridis(length(std$rates)),
  #   lwd = 2
  # )
  
  data <- as.data.frame(std$rates)
  data$depth <- grid$x.mid
  
  fig <- plot_ly(data, type = 'scatter', mode = 'lines', line = list(width = 3))
  for (rate in reactions) {
    fig <- fig %>% add_trace(y = ~depth, x = std$rates[[rate]], name = rate)
  }
  fig <- fig %>% layout(
    title = title,
    xaxis = list(title = "reaction rate (mol/(m3_bulk yr))"),
    yaxis = list(title = "depth (m)", range = c(length,0)),
    font = list(size = 16)
  )
    
  fig
}

plot_omega <- function(std) {
  plot(
    x = std$omega_siderite,
    y = grid$x.mid,
    ylim = c(max(grid$x.int), min(grid$x.int)),
    type = "l",
    lwd = 2,
    xlab = "omega siderite",
    ylab = "depth (m)",
    log = "x"
  )
}
```

### Plot Runge-Kutta results

```{r def plot functions 2}
#| echo: true
#| code-fold: true

plot_std_conc_evolution <- function(std_matrix_list, selection, N_lines, grid) {
  
  data <- std_matrix_list[[selection]]
  
  # number of available timesteps
  available_timesteps <- ncol(data)
  
  # selection of N_lines timesteps
  selected_timesteps <- floor(seq.int(1, available_timesteps, length.out = N_lines))
  
  # reduce data
  data <- data[,selected_timesteps]
  
  # plot
  matplot(y = grid$x.mid,
          x = data,
          type = "l",
          ylim = c(max(grid$x.mid), min(grid$x.mid)),
          xlab = "concentration (mol/m^3_phase)",
          ylab = "depth (m)",
          main = selection)
}

plot_std_rate_evolution <- function(std, selection, N_lines) {
  
  data <- std$rates_split[[selection]]
  
  # number of available depths
  available_depths <- nrow(data)
  
  # selection of N_lines depths
  selected_depths <- floor(seq.int(1, available_depths, length.out = N_lines))
  
  # reduce data
  data <- data[selected_depths,]
  
  # plot
  matplot(x = std$times,
          y = t(data),
          type = "l",
          ylab = "rate (mol/(m^3_phase * yr))",
          xlab = "time (a)",
          main = selection)
}
```


## Model Setup

### Grid
```{r grid setup}
#| echo: true

length   <- 0.1 # (m)
N_grid   <- 400 # (-)

grid     <- setup.grid.1D(L = length, N = N_grid, dx.1=0.0005)
```

### Porosity / Solid Volume Fraction
```{r porosity}
#| echo: true

porFun.L  <- function(x, por.SWI, por.deep, porcoef) {
  return( por.deep + (por.SWI-por.deep) * exp(-x*porcoef) ) 
}

porFun.S  <- function(x, por.SWI, por.deep, porcoef) {
  return( 1 - porFun.L(x, por.SWI, por.deep, porcoef) ) 
}

por.swi  <- 0.8
por.deep <- 0.8

grid.por <- setup.prop.1D(func = porFun.L, grid = grid, por.SWI = por.swi,
                           por.deep=por.deep, porcoef=100)

grid.svf  <- setup.prop.1D(func = porFun.S, grid = grid, por.SWI = por.swi,
                           por.deep=por.deep, porcoef=100)

conversion_factors <- list(
  s2p = ((grid.svf$mid) / grid.por$mid), # conversion of x/m3_svf to x/m3_pw
  p2s = (grid.por$mid / (grid.svf$mid))  # conversion of x/m3_pw  to x/m3_svf
)
```

### Advective Velocities
```{r advection}
#| echo: true

# sedimentation velocity
v <- 5e-6*365  # (m/yr)

# returns pore water advective velocities (u) and solid phase advective velocities (v)
advective_velocities <- setup.compaction.1D(
    v.0 = v,
    por.0 = por.swi,
    por.inf = por.deep,
    por.grid = grid.por
)
```

### Diffusion Coefficients
```{r diffusion}
#| echo: true

salinity    <- 35 # (psu)
temperature <- 20 # (dgC)
pressure    <- 1.013253 # (bar)
Db          <- 5e-4 # mixing rate of the sediment; Bioturbation coefficient (m2/y)
Db_mid      <- 0.5  # middle of Db decreasing zone (m)
Db_width    <- 0.01 # width of Db decreasing zone (m)

grid.Db <- setup.prop.1D(
    func = p.sig,
    y.0 = Db,
    y.inf = 0,
    x.L = Db_mid,
    x.att = Db_width,
    grid = grid
)

tortuosity_squared <- 1-log(grid.por$int^2)

s2yr <- 3600*24*365.25

diffcoeff_species <- c("HCO3", "HCO3", "CH4", "H2PO4", "NO3", "NH4", "SO4",
                       "O2", "Mn", "Fe", "H2S", "N2")

diffcoeffs <- diffcoeff(
  species = diffcoeff_species,
  S = salinity,
  t = temperature,
  P = pressure
)

diffusion_coefficients <- list(
  
  # solute: molar diffusion coefficient / tortuosity**2 + bioturbation coefficient
  # solid: bioturbation coefficient
  
  ALK   = diffcoeffs[[1]]  * s2yr / tortuosity_squared + grid.Db$int,
  DIC   = diffcoeffs[[2]]  * s2yr / tortuosity_squared + grid.Db$int,
  CH4   = diffcoeffs[[3]]  * s2yr / tortuosity_squared + grid.Db$int,
  H2PO4 = diffcoeffs[[4]]  * s2yr / tortuosity_squared + grid.Db$int,
  NO3   = diffcoeffs[[5]]  * s2yr / tortuosity_squared + grid.Db$int,
  NH4   = diffcoeffs[[6]]  * s2yr / tortuosity_squared + grid.Db$int,
  SO4   = diffcoeffs[[7]]  * s2yr / tortuosity_squared + grid.Db$int,
  O2    = diffcoeffs[[8]]  * s2yr / tortuosity_squared + grid.Db$int,
  Mn2   = diffcoeffs[[9]]  * s2yr / tortuosity_squared + grid.Db$int,
  Fe2   = diffcoeffs[[10]] * s2yr / tortuosity_squared + grid.Db$int,
  H2S   = diffcoeffs[[11]] * s2yr / tortuosity_squared + grid.Db$int,
  N2    = diffcoeffs[[12]] * s2yr / tortuosity_squared + grid.Db$int,
  solid = grid.Db$int
    
)
```

```{r plot por, Db, ...}
#| layout-ncol: 4
#| fig.height: 3.5
#| fig.width: 3.5

plot(x=grid.por$mid, y=grid$x.mid, type="l",
     ylim=c(length,0), ylab="depth (m)", xlab="porosity (m3_liq/m3_bulk)")
plot(x=diffusion_coefficients$solid, y=grid$x.int, type="l",
     ylim=c(length,0), ylab="depth (m)", xlab="D_solid (m2/yr)")
plot(x=diffusion_coefficients$DIC, y=grid$x.int, type="l",
     ylim=c(length,0), ylab="depth (m)", xlab="D_DIC (m2/yr)")
plot(x=diffusion_coefficients$O2, y=grid$x.int, type="l",
     ylim=c(length,0), ylab="depth (m)", xlab="D_O2 (m2/yr)")
```

### Boundary Conditions
```{r boundary conditions}
#| echo: true

boundary_conditions <- c(
  # Alkalinity in eq/m3?
  ALK_up   = 2,
  # Solutes: concentrations in mol m-3
  DIC_up   = 2,
  CH4_up   = 0,
  H2PO4_up = 0,
  NO3_up   = 0.2,
  NH4_up   = 0.001,
  SO4_up   = 28,
  O2_up    = 0.3,
  N2_up    = 0, # <<<
  Mn2_up   = 0,
  Fe2_up   = 0,
  H2S_up   = 0,
  # Solids: flux in mol m-2 yr-1
  OM_up      = 0.25 * 365,
  MnO2_up    = 10,
  FeOH3_up   = 10,
  FeOH3_P_up = 10,
  FeCO3_up   = 0,
  S0_up      = 0
)
```

### Reaction Parameters
```{r reaction parameters}
#| echo: true

dry_density_sediment <- 2700 # kg/m³

reaction_parameter <- c(
  # OM degradation
  ## reaction constants
  k_alpha = 0.005 * 365, # yr-1
  k_beta  = 0,#0.025,    # yr-1
  ## composition of OM
  OM_a    = 1,
  OM_b    = 16 / 106,
  OM_c    = 1 / 106,
  ## limitation / inhibition constants (mol m-3)
  K_O2    = 0.001,
  K_NO3   = 0.001,
  K_MnO2  = 0.001 * dry_density_sediment,#0.004 * dry_density_sediment,
  K_FeOH3 = 0.001 * dry_density_sediment,#0.065 * dry_density_sediment,
  K_SO4   = 0.1,
  K_H3PO4 = 10^-5,
  ## ratio of Fe to P in Fe(OH)_3(H3PO4)_lambda
  lambda  = 0.6,
  # Siderite Precipitation / Dissolution
  k_precip_siderite = 1.8e2, # mol m-3_sf yr-1
  k_diss_siderite = 2.5e-1,  # yr-1
  Ksp_siderite = 10**(-10.4) * 1000**2,
  # FeOH3 / FeOH3~H3PO4-Reduction coupled to Sulphide Oxidation
  k_Fe_red_S_ox = 10**2, # m3 mol-1 yr-1
  # FeOH3 / FeOH3~H3PO4-Formation
  k_FeOH3_formation = 1.4e2 # m3 mol-1 yr-1
)
```

### Collect Inputs
```{r collect inputs}
#| echo: true

parameter <- c(
  N_grid = N_grid,
  conversion_factors,
  boundary_conditions,
  reaction_parameter,
  logK = logK,
  tableau = tableau
)

N_species <- length(model_species)
```

### Model Function
```{r model function}
#| echo: true
#| code-fold: show

model <- function (t, state, parms, diff_coeffs, adv_vel, solve_equilibrium, precipitation){
  
  with (as.list(parms),{
    
    # assign state variables
    i <- 1
    # state variables for solutes are total amounts,
    # but implicitly concentrations (total_amount/m³_pw)
    ALK     <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1 # -TOT_H
    DIC     <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1 # TOT_H2CO3
    TOT_P   <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    TOT_N5  <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    TOT_N3  <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    TOT_S6  <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    TOT_S2  <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    CH4     <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    O2      <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    N2      <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    Mn2     <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    Fe2     <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    # state variables for solids are tableau-species concentrations (mol/m3_svf)
    MnO2    <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    OM      <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    FeOH3   <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    FeOH3_P <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    FeCO3   <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    S0      <- state[((i-1) * N_grid + 1) : (i * N_grid)]; i <- i + 1
    
    
    # transport terms
    tran.ALK     <- tran.1D(C = ALK, C.up = ALK_up, D = diff_coeffs$ALK, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.DIC     <- tran.1D(C = DIC, C.up = DIC_up, D = diff_coeffs$DIC, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.TOT_P   <- tran.1D(C = TOT_P, C.up = H2PO4_up, D = diff_coeffs$H2PO4, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.TOT_N5  <- tran.1D(C = TOT_N5, C.up = NO3_up, D = diff_coeffs$NO3, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.TOT_N3  <- tran.1D(C = TOT_N3, C.up = NH4_up, D = diff_coeffs$NH4, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.TOT_S6  <- tran.1D(C = TOT_S6, C.up = SO4_up, D = diff_coeffs$SO4, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.TOT_S2  <- tran.1D(C = TOT_S2, C.up = H2S_up, D = diff_coeffs$H2S, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.CH4     <- tran.1D(C = CH4, C.up = CH4_up, D = diff_coeffs$CH4, 
                            v = adv_vel$u, VF = grid.por, dx = grid)

    tran.O2      <- tran.1D(C = O2, C.up = O2_up, D = diff_coeffs$O2, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.N2      <- tran.1D(C = N2, C.up = N2_up, D = diff_coeffs$N2, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.Mn2     <- tran.1D(C = Mn2, C.up = Mn2_up, D = diff_coeffs$Mn2, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.Fe2     <- tran.1D(C = Fe2, C.up = Fe2_up, D = diff_coeffs$Fe2, 
                            v = adv_vel$u, VF = grid.por, dx = grid)
    
    tran.MnO2    <- tran.1D(C = MnO2, flux.up = MnO2_up, D = diff_coeffs$solid, 
                            v = adv_vel$v, VF = grid.svf, dx = grid)
    
    tran.OM      <- tran.1D(C = OM, flux.up = OM_up, D = diff_coeffs$solid, 
                            v = adv_vel$v, VF = grid.svf, dx = grid)
    
    tran.FeOH3   <- tran.1D(C = FeOH3, flux.up = FeOH3_up, D = diff_coeffs$solid, 
                            v = adv_vel$v, VF = grid.svf, dx = grid)
    
    tran.FeOH3_P <- tran.1D(C = FeOH3_P, flux.up = FeOH3_P_up, D = diff_coeffs$solid, 
                            v = adv_vel$v, VF = grid.svf, dx = grid)
    
    tran.FeCO3   <- tran.1D(C = FeCO3, flux.up = FeCO3_up, D = diff_coeffs$solid, 
                            v = adv_vel$v, VF = grid.svf, dx = grid)

    tran.S0      <- tran.1D(C = S0, flux.up = S0_up, D = diff_coeffs$solid, 
                            v = adv_vel$v, VF = grid.svf, dx = grid)
    
    
    # calculate solute equilibrium species (solve the tableau)
    if (solve_equilibrium) {
      # 1) grep the solute total components; here we need TOT_H = - ALK
      solute_totals <- c(-ALK, DIC, TOT_P, TOT_N5, TOT_N3, TOT_S6, TOT_S2)
      # 2) solve tableau
      solute_equilibrium  <- solve_tableau(solute_totals, tableau, logK, N_grid)
      # 3) assign results
      pH    <- -log10(solute_equilibrium$species_conc[,1] * 10^-3)
      OH    <- solute_equilibrium$species_conc[,2]
      H2CO3 <- solute_equilibrium$species_conc[,3]
      HCO3  <- solute_equilibrium$species_conc[,4]
      CO3   <- solute_equilibrium$species_conc[,5]
      H3PO4 <- solute_equilibrium$species_conc[,6]
      HPO4  <- solute_equilibrium$species_conc[,7]
      PO4   <- solute_equilibrium$species_conc[,8]
      HNO3  <- solute_equilibrium$species_conc[,9]
      NO3   <- solute_equilibrium$species_conc[,10]
      NH4   <- solute_equilibrium$species_conc[,11]
      NH3   <- solute_equilibrium$species_conc[,12]
      H2SO4 <- solute_equilibrium$species_conc[,13]
      HSO4  <- solute_equilibrium$species_conc[,14]
      SO4   <- solute_equilibrium$species_conc[,15]
      H2S   <- solute_equilibrium$species_conc[,16]
      HS    <- solute_equilibrium$species_conc[,17]
      S2    <- solute_equilibrium$species_conc[,18]
    } else {
      solute_equilibrium <- NA
    }
    
    # FeOH3 fractions
    FeOH3_tot <- FeOH3 + FeOH3_P
    chi <- rep(1, length(FeOH3))
    ind_valid <- FeOH3_tot > 0
    chi[ind_valid] <- FeOH3[ind_valid] / FeOH3_tot[ind_valid]
    
    # limitation & inhibition terms
    L_O2    <- O2   / (K_O2 + O2)
    I_O2    <- K_O2 / (K_O2 + O2)
    
    L_NO3   <- TOT_N5 / (K_NO3 + TOT_N5)
    I_NO3   <- K_NO3 / (K_NO3 + TOT_N5)
    
    L_MnO2  <- MnO2   / (K_MnO2 + MnO2)
    I_MnO2  <- K_MnO2 / (K_MnO2 + MnO2)
    
    L_FeOH3 <- FeOH3_tot / (K_FeOH3 + FeOH3_tot)
    I_FeOH3 <- K_FeOH3 / (K_FeOH3 + FeOH3_tot)
    
    L_SO4   <- TOT_S6 / (K_SO4 + TOT_S6)
    I_SO4   <- K_SO4 / (K_SO4 + TOT_S6)
    
    L_H3PO4 <- TOT_P   / (K_H3PO4 + TOT_P)
    I_H3PO4 <- K_H3PO4 / (K_H3PO4 + TOT_P)
    
    # Reaction Rates
    ## OM Degradation
    R1 <- k_alpha * OM * L_O2
    R2 <- k_alpha * OM * L_NO3                            * I_O2
    R3 <- k_alpha * OM * L_MnO2                   * I_NO3 * I_O2
    R4 <- k_alpha * OM * L_FeOH3         * I_MnO2 * I_NO3 * I_O2
    R5 <- k_alpha * OM * L_SO4 * I_FeOH3 * I_MnO2 * I_NO3 * I_O2
    R6 <- k_alpha * OM * I_SO4 * I_FeOH3 * I_MnO2 * I_NO3 * I_O2

    ## Siderite: R7 = precipitation, R8 = dissolution
    if (precipitation & solve_equilibrium) {
      omega_siderite <- (Fe2 * CO3) / Ksp_siderite
    } else if (precipitation) {
      omega_siderite <- (Fe2 * DIC * 0.0001) / Ksp_siderite # !!!
    }
    else {
      omega_siderite <- rep(1, N_grid)
    }
    R7 <- ifelse(omega_siderite > 1, k_precip_siderite * (omega_siderite - 1)^2, 0)
    R8 <- ifelse(omega_siderite < 1, k_diss_siderite * FeCO3 * (1 - omega_siderite)^2, 0)

    ## FeOH3 / FeOH3~H3PO4-Reduction coupled to Sulphide Oxidation
    if (solve_equilibrium) {
      R9 <- k_Fe_red_S_ox * FeOH3_tot * H2S
    } else {
      R9 <- k_Fe_red_S_ox * FeOH3_tot * TOT_S2
    }

    ## FeOH3 / FeOH3~H3PO4-Formation
    R10 <- k_FeOH3_formation * O2 * Fe2

    
    # change of species concentration due to reactions
    ## solutes step1: change of slow-reaction-species (srs), the ones for which
    ## the reactions are formulated, according to reaction stoichiometry
    R.srs_O2    <- (- s2p * R1                   # OM Degradation
                    - 1 * R10)
    R.srs_CO2   <- (s2p * (R1 + R2 + R3 + R4 + R5 + 1/2 * R6)
                    - s2p * R7 + s2p * R8)  # Siderite Precipitation / Dissolution
    R.srs_NH3   <- OM_b * s2p * (R1 + R2 + R3 + R4 + R5 + R6)
    R.srs_H3PO4 <- (s2p * ( OM_c * (R1 + R2 + R3 + R5 + R6) +
                      (OM_c + (1 - chi) * 4 * lambda) * R4 )
                    + 2 * (1 - chi) * lambda * s2p * R9
                    - 4 * lambda * L_H3PO4 * R10)
    R.srs_HNO3  <- - 4/5 * s2p * R2
    R.srs_N2    <- 2/5 * s2p * R2
    R.srs_FeOH2 <- (4 * s2p * R4                # OM degradation
                    - s2p * R7 + s2p * R8       # Siderite Precipitation / Dissolution
                    + 2 * s2p * R9
                    - 4 * R10)
    R.srs_MnOH2 <- 2 * s2p * R3
    R.srs_H2SO4 <- - 1/2 * s2p * R5
    R.srs_H2S   <- (1/2 * s2p * R5
                    - 1 * s2p * R9)
    R.srs_CH4   <- 1/2 * s2p * R6
    
    ## solutes step2: change of tableau-components = model species
    ## translation of change of slow-reaction-species to change of 
    ## tableau components using the translation table
    ## here the component-total "H" is already converted to alkalinity (*-1)
    R.ALK   <- -1 * (- R.srs_NH3 + R.srs_H3PO4 + R.srs_HNO3 - 2 * R.srs_FeOH2
                     - 2 * R.srs_MnOH2 + 2 * R.srs_H2SO4)
    R.DIC    <- R.srs_CO2
    R.CH4    <- R.srs_CH4
    R.TOT_P  <- R.srs_H3PO4
    R.TOT_N5 <- R.srs_HNO3
    R.TOT_N3 <- R.srs_NH3
    R.TOT_S6 <- R.srs_H2SO4
    R.TOT_S2 <- R.srs_H2S
    R.O2     <- R.srs_O2
    R.N2     <- R.srs_N2
    R.Mn2    <- R.srs_MnOH2
    R.Fe2    <- R.srs_FeOH2
    
    ## solids
    R.OM <- - R1 - R2 - R3 - R4 - R5 - R6
    R.MnO2 <- - 2 * R3
    R.FeOH3 <- (- 4 * chi * R4
                - 2 * chi * R9
                + 4 * (1 - L_H3PO4) * p2s * R10)
    R.FeOH3_P <- (- 4 * (1 - chi) * R4
                  - 2 * (1 - chi) * R9
                  + 4 * L_H3PO4 * p2s * R10)
    R.FeCO3 <- R7 - R8
    R.S0 <- R9
    
    # total change in concentration of model species
    dCdt.ALK    <- R.ALK + tran.ALK$dC
    dCdt.DIC    <- R.DIC + tran.DIC$dC
    dCdt.CH4    <- R.CH4 + tran.CH4$dC
    dCdt.TOT_P  <- R.TOT_P + tran.TOT_P$dC
    dCdt.TOT_N5 <- R.TOT_N5 + tran.TOT_N5$dC
    dCdt.TOT_N3 <- R.TOT_N3 + tran.TOT_N3$dC
    dCdt.N2     <- R.N2  + tran.N2$dC
    dCdt.TOT_S6 <- R.TOT_S6 + tran.TOT_S6$dC
    dCdt.TOT_S2 <- R.TOT_S2 + tran.TOT_S2$dC
    dCdt.O2     <- R.O2 + tran.O2$dC
    dCdt.Mn2    <- R.Mn2 + tran.Mn2$dC
    dCdt.Fe2    <- R.Fe2 + tran.Fe2$dC
    dCdt.OM     <- R.OM + tran.OM$dC
    dCdt.MnO2   <- R.MnO2 + tran.MnO2$dC
    dCdt.FeOH3  <- R.FeOH3 + tran.FeOH3$dC
    dCdt.FeOH3_P <- R.FeOH3_P + tran.FeOH3_P$dC
    dCdt.FeCO3  <- R.FeCO3 + tran.FeCO3$dC
    dCdt.S0     <- R.S0 + tran.S0$dC
    
    # characteristic time scales
    # if dCdt.X = 0 -> timescale will be Inf
    time_scales <- c(
      ALK = ALK / dCdt.ALK,
      DIC = DIC / dCdt.DIC,
      CH4 = CH4 / dCdt.CH4,
      TOT_P = TOT_P / dCdt.TOT_P,
      TOT_N5 = TOT_N5 / dCdt.TOT_N5,
      TOT_N3 = TOT_N3 / dCdt.TOT_N3,
      N2 = N2 / dCdt.N2,
      TOT_S6 = TOT_S6 / dCdt.TOT_S6,
      TOT_S2 = TOT_S2 / dCdt.TOT_S2,
      O2 = O2 / dCdt.O2,
      Mn2 = Mn2 / dCdt.Mn2,
      Fe2 = Fe2 / dCdt.Fe2,
      OM = OM / dCdt.OM,
      MnO2 = MnO2 / dCdt.MnO2,
      FeOH3 = FeOH3 / dCdt.FeOH3,
      FeOH3_P = FeOH3_P / dCdt.FeOH3_P,
      FeCO3 = FeCO3 / dCdt.FeCO3,
      S0 = S0 / dCdt.S0
    )
    # but we need to take the absolute value to find the correct minimum
    time_scales <- abs(time_scales)
    # set NaN values to a number (???)
    time_scales[is.na(time_scales)] <- 100
    # set 0 to a small number
    time_scales[time_scales == 0] <- 1e-10

    return(
      list(
        c(
          dCdt.ALK = dCdt.ALK,
          dCdt.DIC = dCdt.DIC,
          dCdt.TOT_P = dCdt.TOT_P,
          dCdt.TOT_N5 = dCdt.TOT_N5,
          dCdt.TOT_N3 = dCdt.TOT_N3,
          dCdt.TOT_S6 = dCdt.TOT_S6,
          dCdt.TOT_S2 = dCdt.TOT_S2,
          dCdt.CH4 = dCdt.CH4,
          dCdt.O2 = dCdt.O2,
          dCdt.N2 = dCdt.N2,
          dCdt.Mn2 = dCdt.Mn2,
          dCdt.Fe2 = dCdt.Fe2,
          dCdt.MnO2 = dCdt.MnO2,
          dCdt.OM = dCdt.OM,
          dCdt.FeOH3 = dCdt.FeOH3,
          dCdt.FeOH3_P = dCdt.FeOH3_P,
          dCdt.FeCO3 = dCdt.FeCO3,
          dCdt.S0 = dCdt.S0
        ),
        transport = list(
          tran.ALK = tran.ALK,
          tran.DIC = tran.DIC,
          tran.TOT_P = tran.TOT_P,
          tran.TOT_N5 = tran.TOT_N5,
          tran.TOT_N3 = tran.TOT_N3,
          tran.TOT_S6 = tran.TOT_S6,
          tran.TOT_S2 = tran.TOT_S2,
          tran.CH4 = tran.CH4,
          tran.O2 = tran.O2,
          tran.N2 = tran.N2,
          tran.Mn2 = tran.Mn2,
          tran.Fe2 = tran.Fe2,
          tran.MnO2 = tran.MnO2,
          tran.OM = tran.OM,
          tran.FeOH3 = tran.FeOH3,
          tran.FeOH3_P = tran.FeOH3_P,
          tran.FeCO3 = tran.FeCO3,
          tran.S0 = tran.S0
        ),
        sumR = list(
          R.ALK     = R.ALK * grid.por$mid,
          R.DIC     = R.DIC * grid.por$mid,
          R.TOT_P   = R.TOT_P * grid.por$mid,
          R.TOT_N5  = R.TOT_N5 * grid.por$mid,
          R.TOT_N3  = R.TOT_N3 * grid.por$mid,
          R.TOT_S6  = R.TOT_S6 * grid.por$mid,
          R.TOT_S2  = R.TOT_S2 * grid.por$mid,
          R.CH4     = R.CH4 * grid.por$mid,
          R.O2      = R.O2 * grid.por$mid,
          R.N2      = R.N2 * grid.por$mid,
          R.Mn2     = R.Mn2 * grid.por$mid,
          R.Fe2     = R.Fe2 * grid.por$mid,
          R.MnO2    = R.MnO2 * grid.svf$mid,
          R.OM      = R.OM * grid.svf$mid,
          R.FeOH3   = R.FeOH3 * grid.svf$mid,
          R.FeOH3_P = R.FeOH3_P * grid.svf$mid,
          R.FeCO3   = R.FeCO3 * grid.svf$mid,
          R.S0 = R.S0 * grid.svf$mid
        ),
        rates = list(
          R1  = R1 * grid.svf$mid,
          R2  = R2 * grid.svf$mid,
          R3  = R3 * grid.svf$mid,
          R4  = R4 * grid.svf$mid,
          R5  = R5 * grid.svf$mid,
          R6  = R6 * grid.svf$mid,
          R7  = R7 * grid.svf$mid,
          R8  = R8 * grid.svf$mid,
          R9  = R9 * grid.svf$mid,
          R10 = R10 * grid.svf$mid
        ),
        solute_equilibrium = solute_equilibrium,
        time_scales = time_scales,
        omega_siderite = omega_siderite,
        timescale_Fe2 = Fe2 / dCdt.Fe2,
        dCdt_Fe2 = dCdt.Fe2
      )
    )
 })
}
```


## Solve Model

### 1) Steady State

Steady State is found in a two step procedure:

1) Solve steady state without equilibrium solver. All reactions are controlled by component-totals. If necessary, pH dependent speciation is estiamted based on **???**
2) Solve steady state with equilibrium solver. All reaction now are controlled by the actual concentrations.

```{r std1}
#| echo: true

initial <- rep(1e-4, N_grid * N_species)

std1 <- steady.1D(
  y = initial,
  func = model,
  parms = parameter, 
  dimens = N_grid,
  nspec = N_species,
  names = model_species,
  positive = TRUE,
  method = "stodes",
  diff_coeffs = diffusion_coefficients,
  adv_vel = advective_velocities,
  solve_equilibrium = FALSE,
  precipitation = TRUE
)
```

```{r std2}
#| echo: true

std2 <- steady.1D(
  y = std1$y,
  func = model,
  parms = parameter,
  dimens = N_grid,
  nspec = N_species,
  names = model_species,
  positive = TRUE,
  method = "stode", # stode gives back result, even if steady state is not reached
                    # stodes does not return intermediate result
  maxiter = 100,
  diff_coeffs = diffusion_coefficients,
  adv_vel = advective_velocities,
  solve_equilibrium = TRUE,
  precipitation = TRUE
)
```


#### Profiles: Component-Totals

```{r plot std2}
#| column: screen-inset
#| layout-ncol: 5
#| fig.height: 3.5
#| fig.width: 3.5

plot_std_profiles(std2)
```

#### Profiles: Speciation

```{r plot std2 speciation}
#| column: screen-inset
#| layout-ncol: 3
#| fig.width: 6

speciation <- std2$solute_equilibrium$species_conc
colnames(speciation) <- tableau_species

rcols <- viridis::viridis(6)

matplot(y=grid$x.mid, x = speciation[,3:5],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6], rcols[1]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("H2CO3", "HCO3", "CO3"),
  lty = 1,
  col = c(rcols[3], rcols[6], rcols[1]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,6:9],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6], rcols[1], rcols[4]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("H3PO4", "H2PO4-", "HPO42-", "PO43-"),
  lty = 1,
  col = c(rcols[3], rcols[6], rcols[1], rcols[4]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,10:11],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("HNO3", "NO3-"),
  lty = 1,
  col = c(rcols[3], rcols[6]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,12:13],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("NH4+", "NH3"),
  lty = 1,
  col = c(rcols[3], rcols[6]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,14:16],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6], rcols[1]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("H2SO4", "HSO4-", "SO42-"),
  lty = 1,
  col = c(rcols[3], rcols[6], rcols[1]),
  lwd = 2
)

matplot(y=grid$x.mid, x = speciation[,17:19],
        type="l", lwd=2, lty=1,
        ylim=c(length,0), 
        col=c(rcols[3], rcols[6], rcols[1]),
        ylab="depth (m)", 
        xlab="mol/m3_phase"
        )
legend(
  x = "topright",
  legend = c("H2S", "HS-", "S2-"),
  lty = 1,
  col = c(rcols[3], rcols[6], rcols[1]),
  lwd = 2
)
```

#### Profile: pH

```{r plot pH}
#| out.width: 100%

pH <- -log10(speciation[,1] * 10^-3) # mol/m3 * 10^-3 m3/L
plot(grid$x.mid ~ pH, ylim = c(0.1, 0), type = "l", ylab = "depth (m)", lwd = 2)
```

#### Profiles: Saturation

```{r plot saturation}
#| out.width: 100%

rcols <- viridis::viridis(2)

omega_siderite <- speciation[,"CO3"] * std1$y[, "Fe2"] / parameter$Ksp_siderite

plot(
    x = std2$omega_siderite,
    y = grid$x.mid,
    ylim = c(max(grid$x.int), min(grid$x.int)),
    type = "l",
    lwd = 2,
    col = rcols[1],
    xlab = "omega siderite",
    ylab = "depth (m)",
    log = "x"
  )
```

#### Profiles: Reaction Rates

##### OM Degradation
```{r plot rates OM Degradation}
#| out.width: 100%

plot_std_rates(std2, c("R1", "R2", "R3", "R4", "R5", "R6"))
```

##### Siderite Precipitation
```{r plot rates Siderite Precip}
#| out.width: 100%

plot_std_rates(std2, c("R7", "R8"))
```

##### FeOH3 / FeOH3~H3PO4-reduction coupled to sulphide oxidation
```{r plot rates FeOH3 reduction}
#| out.width: 100%

plot_std_rates(std2, c("R9"))
```

##### FeOH3 / FeOH3~H3PO4-formation
```{r plot rates FeOH3 formation}
#| out.width: 100%

plot_std_rates(std2, c("R10"))
```


## Mass Balances

### Species-based Mass Balances

The change in concentration of a species $i$, integrated over depth and in relation to the area $A$ is

$$\frac{dC_{A,i}}{dt} \; \left( \frac{mol}{m^2 \cdot a} \right) = J(a)_i - J(b)_i + \int_{a}^b \Psi \sum R_i$$

with

- $J(a)_i$: flux of species $i$ across upper boundary
- $J(b)_i$: flux of species $i$ across lower boundary
- $\Psi$: volume fraction.

```{r std species-based mass balances}
#| echo: true
#| code-fold: true

species_mass_balance <- function(species_vector, std, grid) {
  
  species_mass_balance_inner <- function(species, std, grid) {
  
    tran.species <- paste0("tran.", species)
    flux_up   <- std$transport[[tran.species]]$flux.up
    flux_down <- std$transport[[tran.species]]$flux.down
    netto_flux <- flux_up - flux_down
    
    R.species <- paste0("R.", species)
    sumR_integrated <- sum(std$sumR[[R.species]] * grid$dx)
    
    bilanz <- netto_flux + sumR_integrated
    
    return(data.frame(
      species = species,
      flux_up = flux_up,
      flux_down = flux_down,
      netto_flux = netto_flux,
      sumR_integrated = sumR_integrated,
      bilanz = bilanz
    ))
  }
  
  species_based_mass_balance <- data.frame(
  "Species" = NULL,
  "Flux up" = NULL,
  "Flux down" = NULL,
  "Netto Flux" = NULL,
  "Integral Sum R" = NULL,
  "Bilanz" = NULL
  )
  
  for (species in species_vector) {
    species_based_mass_balance <- rbind(
      species_based_mass_balance,
      species_mass_balance_inner(species, std, grid)
    )
  }
  
  return(species_based_mass_balance)
}

species_mass_balance_std1 <- species_mass_balance(model_species, std1, grid)
species_mass_balance_std2 <- species_mass_balance(model_species, std2, grid)
```

```{r print species based mass balances}
knitr::kable(
  species_mass_balance_std1,
  caption = "std1",
  digits = 20,
  format.args = list(format = "e", digits = 2)
)
knitr::kable(
  species_mass_balance_std2,
  caption = "std2",
  digits = 20,
  format.args = list(format = "e", digits = 2)
)
```


### Element-based Mass Balances

The total amount of an chemical element $e$ is not influenced by chemical reactions.
Therefore, the over the depth integrated and summed up reaction rates of of species $i$ that contain a chemical element is 0.

$$\sum \left[ \frac{e}{i} \cdot \int_{a}^b \Psi \sum R_i \right]_e = 0$$

From this follows, that under stationary conditions the flux in and out of the sediment domain cancel out.

$$\frac{dC_{A,e}}{dt} \; \left( \frac{mol}{m^2 \cdot a} \right) = J(a)_e - J(b)_e = 0$$

**Elemental Composition of Model-Species**
```{r elemental composition}

elemental_composition <- list(
  C = data.frame(
    species = c("DIC", "CH4", "OM", "FeCO3"),
    stoic   = c(1, 1, 1, 1)
  ),
  N = data.frame(
    species = c("TOT_N5", "TOT_N3", "N2", "OM"),
    stoic   = c(1, 1, 2, reaction_parameter[["OM_b"]])
  ),
  P = data.frame(
    species = c("TOT_P", "OM", "FeOH3_P"),
    stoic   = c(1, reaction_parameter[["OM_c"]], reaction_parameter[["lambda"]])
  ),
  S = data.frame(
    species = c("TOT_S6", "TOT_S2", "S0"),
    stoic   = c(1, 1, 1)
  ),
  Fe = data.frame(
    species = c("Fe2", "FeOH3", "FeOH3_P", "FeCO3"),
    stoic   = c(1, 1, 1, 1)
  ),
  Mn = data.frame(
    species = c("Mn2", "MnO2"),
    stoic   = c(1, 1)
  )
)
```

```{r print elemental composition}
#| layout-ncol: 3
#| results: "asis"

for (i in seq_len(length(elemental_composition))) {
  print(knitr::kable(
    elemental_composition[[i]],
    caption = names(elemental_composition[i]),
    digits = 5,
    valign = "t",
    booktabs = TRUE
  ))
}
```

```{r element based mass balance}
#| echo: true
#| code-fold: true

element_mass_balance <- function(elemental_composition, std, grid) {
  
  species_sumR_integrated <- function(species, std, grid) {
    
    R.species <- paste0("R.", species)
    sumR_integrated <- sum(std$sumR[[R.species]] * grid$dx)
    
    return(sumR_integrated)
  }

  species_boundary_fluxes <- function(species, std, grid) {
  
    tran.species <- paste0("tran.", species)
    flux_up   <- std$transport[[tran.species]]$flux.up
    flux_down <- std$transport[[tran.species]]$flux.down
    
    return(list(
      flux_up = flux_up,
      flux_down = flux_down
    ))
  }

  elements <- names(elemental_composition)
  
  overview <- data.frame(
    "Element" = NULL,
    "Netto Flux" = NULL,
    "Integral Sum R" = NULL
  )

  detailed <- list()
  
  for (element in elements) {

    composition <- elemental_composition[[element]]

    detailed_part <- data.frame(
      "Species" = NULL,
      "Flux up" = NULL,
      "Flux down" = NULL,
      "Intergal Sum R" = NULL
    )

    # for every species in which an element is present ...
    for (i in seq_len(nrow(composition))) {
      species <- composition$species[i]
      stoic   <- composition$stoic[i]

      sumR <- species_sumR_integrated(species, std, grid) * stoic

      boundary_fluxes <- species_boundary_fluxes(species, std, grid)
      flux_up <- boundary_fluxes$flux_up * stoic
      flux_down <- boundary_fluxes$flux_down * stoic

      detailed_part <- rbind(
        detailed_part,
        data.frame(
          "Species" = species,
          "Flux up" = flux_up,
          "Flux down" = flux_down,
          "Integral Sum R" = sumR
        )
      )
    }

    detailed[[element]] <- detailed_part

    net_flux <- sum(detailed_part[["Flux.up"]]) - sum(detailed_part[["Flux.down"]])
    net_rate <- sum(detailed_part[["Integral.Sum.R"]])

    overview <- rbind(
      overview,
      data.frame(
        "Element" = element,
        "Netto Flux" = net_flux,
        "Integral Sum R" = net_rate
      )
    )
  }
  
  return(list(
    overview = overview,
    detailed = detailed
  ))
}

element_mass_balance_std1 <- element_mass_balance(elemental_composition, std1, grid)
element_mass_balance_std2 <- element_mass_balance(elemental_composition, std2, grid)
```

```{r print element based mass balances}
#| layout-ncol: 2

knitr::kable(
  element_mass_balance_std1$overview,
  caption = "std1",
  digits = 20,
  format.args = list(format = "e", digits = 2),
  valign = "t"
)
knitr::kable(
  element_mass_balance_std2$overview,
  caption = "std2",
  digits = 20,
  format.args = list(format = "e", digits = 2),
  valign = "t"
)
```
